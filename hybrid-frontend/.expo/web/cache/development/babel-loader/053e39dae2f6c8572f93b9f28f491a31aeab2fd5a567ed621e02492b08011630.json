{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nfunction _createForOfIteratorHelperLoose(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport { PointerType } from \"../../PointerType\";\nimport { State } from \"../../State\";\nimport PointerTracker from \"./PointerTracker\";\nvar GestureHandlerOrchestrator = function () {\n  function GestureHandlerOrchestrator() {\n    _classCallCheck(this, GestureHandlerOrchestrator);\n    _defineProperty(this, \"gestureHandlers\", []);\n    _defineProperty(this, \"awaitingHandlers\", []);\n    _defineProperty(this, \"awaitingHandlersTags\", new Set());\n    _defineProperty(this, \"handlingChangeSemaphore\", 0);\n    _defineProperty(this, \"activationIndex\", 0);\n  }\n  return _createClass(GestureHandlerOrchestrator, [{\n    key: \"scheduleFinishedHandlersCleanup\",\n    value: function scheduleFinishedHandlersCleanup() {\n      if (this.handlingChangeSemaphore === 0) {\n        this.cleanupFinishedHandlers();\n      }\n    }\n  }, {\n    key: \"cleanHandler\",\n    value: function cleanHandler(handler) {\n      handler.reset();\n      handler.setActive(false);\n      handler.setAwaiting(false);\n      handler.setActivationIndex(Number.MAX_VALUE);\n    }\n  }, {\n    key: \"removeHandlerFromOrchestrator\",\n    value: function removeHandlerFromOrchestrator(handler) {\n      var indexInGestureHandlers = this.gestureHandlers.indexOf(handler);\n      var indexInAwaitingHandlers = this.awaitingHandlers.indexOf(handler);\n      if (indexInGestureHandlers >= 0) {\n        this.gestureHandlers.splice(indexInGestureHandlers, 1);\n      }\n      if (indexInAwaitingHandlers >= 0) {\n        this.awaitingHandlers.splice(indexInAwaitingHandlers, 1);\n        this.awaitingHandlersTags.delete(handler.getTag());\n      }\n    }\n  }, {\n    key: \"cleanupFinishedHandlers\",\n    value: function cleanupFinishedHandlers() {\n      var handlersToRemove = new Set();\n      for (var i = this.gestureHandlers.length - 1; i >= 0; --i) {\n        var handler = this.gestureHandlers[i];\n        if (this.isFinished(handler.getState()) && !handler.isAwaiting()) {\n          this.cleanHandler(handler);\n          handlersToRemove.add(handler);\n        }\n      }\n      this.gestureHandlers = this.gestureHandlers.filter(function (handler) {\n        return !handlersToRemove.has(handler);\n      });\n    }\n  }, {\n    key: \"hasOtherHandlerToWaitFor\",\n    value: function hasOtherHandlerToWaitFor(handler) {\n      var _this = this;\n      var hasToWaitFor = function hasToWaitFor(otherHandler) {\n        return !_this.isFinished(otherHandler.getState()) && _this.shouldHandlerWaitForOther(handler, otherHandler);\n      };\n      return this.gestureHandlers.some(hasToWaitFor);\n    }\n  }, {\n    key: \"shouldBeCancelledByFinishedHandler\",\n    value: function shouldBeCancelledByFinishedHandler(handler) {\n      var _this2 = this;\n      var shouldBeCancelled = function shouldBeCancelled(otherHandler) {\n        return _this2.shouldHandlerWaitForOther(handler, otherHandler) && otherHandler.getState() === State.END;\n      };\n      return this.gestureHandlers.some(shouldBeCancelled);\n    }\n  }, {\n    key: \"tryActivate\",\n    value: function tryActivate(handler) {\n      if (this.shouldBeCancelledByFinishedHandler(handler)) {\n        handler.cancel();\n        return;\n      }\n      if (this.hasOtherHandlerToWaitFor(handler)) {\n        this.addAwaitingHandler(handler);\n        return;\n      }\n      var handlerState = handler.getState();\n      if (handlerState === State.CANCELLED || handlerState === State.FAILED) {\n        return;\n      }\n      if (this.shouldActivate(handler)) {\n        this.makeActive(handler);\n        return;\n      }\n      if (handlerState === State.ACTIVE) {\n        handler.fail();\n        return;\n      }\n      if (handlerState === State.BEGAN) {\n        handler.cancel();\n      }\n    }\n  }, {\n    key: \"shouldActivate\",\n    value: function shouldActivate(handler) {\n      var _this3 = this;\n      var shouldBeCancelledBy = function shouldBeCancelledBy(otherHandler) {\n        return _this3.shouldHandlerBeCancelledBy(handler, otherHandler);\n      };\n      return !this.gestureHandlers.some(shouldBeCancelledBy);\n    }\n  }, {\n    key: \"cleanupAwaitingHandlers\",\n    value: function cleanupAwaitingHandlers(handler) {\n      var _this4 = this;\n      var shouldWait = function shouldWait(otherHandler) {\n        return !otherHandler.isAwaiting() && _this4.shouldHandlerWaitForOther(otherHandler, handler);\n      };\n      for (var _iterator = _createForOfIteratorHelperLoose(this.awaitingHandlers), _step; !(_step = _iterator()).done;) {\n        var otherHandler = _step.value;\n        if (shouldWait(otherHandler)) {\n          this.cleanHandler(otherHandler);\n          this.awaitingHandlersTags.delete(otherHandler.getTag());\n        }\n      }\n      this.awaitingHandlers = this.awaitingHandlers.filter(function (otherHandler) {\n        return _this4.awaitingHandlersTags.has(otherHandler.getTag());\n      });\n    }\n  }, {\n    key: \"onHandlerStateChange\",\n    value: function onHandlerStateChange(handler, newState, oldState, sendIfDisabled) {\n      if (!handler.isEnabled() && !sendIfDisabled) {\n        return;\n      }\n      this.handlingChangeSemaphore += 1;\n      if (this.isFinished(newState)) {\n        for (var _iterator2 = _createForOfIteratorHelperLoose(this.awaitingHandlers), _step2; !(_step2 = _iterator2()).done;) {\n          var otherHandler = _step2.value;\n          if (!this.shouldHandlerWaitForOther(otherHandler, handler) || !this.awaitingHandlersTags.has(otherHandler.getTag())) {\n            continue;\n          }\n          if (newState !== State.END) {\n            this.tryActivate(otherHandler);\n            continue;\n          }\n          otherHandler.cancel();\n          if (otherHandler.getState() === State.END) {\n            otherHandler.sendEvent(State.CANCELLED, State.BEGAN);\n          }\n          otherHandler.setAwaiting(false);\n        }\n      }\n      if (newState === State.ACTIVE) {\n        this.tryActivate(handler);\n      } else if (oldState === State.ACTIVE || oldState === State.END) {\n        if (handler.isActive()) {\n          handler.sendEvent(newState, oldState);\n        } else if (oldState === State.ACTIVE && (newState === State.CANCELLED || newState === State.FAILED)) {\n          handler.sendEvent(newState, State.BEGAN);\n        }\n      } else if (oldState !== State.UNDETERMINED || newState !== State.CANCELLED) {\n        handler.sendEvent(newState, oldState);\n      }\n      this.handlingChangeSemaphore -= 1;\n      this.scheduleFinishedHandlersCleanup();\n      if (!this.awaitingHandlers.includes(handler)) {\n        this.cleanupAwaitingHandlers(handler);\n      }\n    }\n  }, {\n    key: \"makeActive\",\n    value: function makeActive(handler) {\n      var currentState = handler.getState();\n      handler.setActive(true);\n      handler.setShouldResetProgress(true);\n      handler.setActivationIndex(this.activationIndex++);\n      for (var i = this.gestureHandlers.length - 1; i >= 0; --i) {\n        if (this.shouldHandlerBeCancelledBy(this.gestureHandlers[i], handler)) {\n          this.gestureHandlers[i].cancel();\n        }\n      }\n      for (var _iterator3 = _createForOfIteratorHelperLoose(this.awaitingHandlers), _step3; !(_step3 = _iterator3()).done;) {\n        var otherHandler = _step3.value;\n        if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n          otherHandler.setAwaiting(false);\n        }\n      }\n      handler.sendEvent(State.ACTIVE, State.BEGAN);\n      if (currentState !== State.ACTIVE) {\n        handler.sendEvent(State.END, State.ACTIVE);\n        if (currentState !== State.END) {\n          handler.sendEvent(State.UNDETERMINED, State.END);\n        }\n      }\n      if (!handler.isAwaiting()) {\n        return;\n      }\n      handler.setAwaiting(false);\n      this.awaitingHandlers = this.awaitingHandlers.filter(function (otherHandler) {\n        return otherHandler !== handler;\n      });\n    }\n  }, {\n    key: \"addAwaitingHandler\",\n    value: function addAwaitingHandler(handler) {\n      if (this.awaitingHandlers.includes(handler)) {\n        return;\n      }\n      this.awaitingHandlers.push(handler);\n      this.awaitingHandlersTags.add(handler.getTag());\n      handler.setAwaiting(true);\n      handler.setActivationIndex(this.activationIndex++);\n    }\n  }, {\n    key: \"recordHandlerIfNotPresent\",\n    value: function recordHandlerIfNotPresent(handler) {\n      if (this.gestureHandlers.includes(handler)) {\n        return;\n      }\n      this.gestureHandlers.push(handler);\n      handler.setActive(false);\n      handler.setAwaiting(false);\n      handler.setActivationIndex(Number.MAX_SAFE_INTEGER);\n    }\n  }, {\n    key: \"shouldHandlerWaitForOther\",\n    value: function shouldHandlerWaitForOther(handler, otherHandler) {\n      return handler !== otherHandler && (handler.shouldWaitForHandlerFailure(otherHandler) || otherHandler.shouldRequireToWaitForFailure(handler));\n    }\n  }, {\n    key: \"canRunSimultaneously\",\n    value: function canRunSimultaneously(gh1, gh2) {\n      return gh1 === gh2 || gh1.shouldRecognizeSimultaneously(gh2) || gh2.shouldRecognizeSimultaneously(gh1);\n    }\n  }, {\n    key: \"shouldHandlerBeCancelledBy\",\n    value: function shouldHandlerBeCancelledBy(handler, otherHandler) {\n      if (this.canRunSimultaneously(handler, otherHandler)) {\n        return false;\n      }\n      if (handler.isAwaiting() || handler.getState() === State.ACTIVE) {\n        return handler.shouldBeCancelledByOther(otherHandler);\n      }\n      var handlerPointers = handler.getTrackedPointersID();\n      var otherPointers = otherHandler.getTrackedPointersID();\n      if (!PointerTracker.shareCommonPointers(handlerPointers, otherPointers) && handler.getDelegate().getView() !== otherHandler.getDelegate().getView()) {\n        return this.checkOverlap(handler, otherHandler);\n      }\n      return true;\n    }\n  }, {\n    key: \"checkOverlap\",\n    value: function checkOverlap(handler, otherHandler) {\n      var isPointerWithinBothBounds = function isPointerWithinBothBounds(pointer) {\n        var handlerX = handler.getTracker().getLastX(pointer);\n        var handlerY = handler.getTracker().getLastY(pointer);\n        var point = {\n          x: handlerX,\n          y: handlerY\n        };\n        return handler.getDelegate().isPointerInBounds(point) && otherHandler.getDelegate().isPointerInBounds(point);\n      };\n      var handlerPointers = handler.getTrackedPointersID();\n      var otherPointers = otherHandler.getTrackedPointersID();\n      return handlerPointers.some(isPointerWithinBothBounds) || otherPointers.some(isPointerWithinBothBounds);\n    }\n  }, {\n    key: \"isFinished\",\n    value: function isFinished(state) {\n      return state === State.END || state === State.FAILED || state === State.CANCELLED;\n    }\n  }, {\n    key: \"cancelMouseAndPenGestures\",\n    value: function cancelMouseAndPenGestures(currentHandler) {\n      this.gestureHandlers.forEach(function (handler) {\n        if (handler.getPointerType() !== PointerType.MOUSE && handler.getPointerType() !== PointerType.STYLUS) {\n          return;\n        }\n        if (handler !== currentHandler) {\n          handler.cancel();\n        } else {\n          handler.getTracker().resetTracker();\n        }\n      });\n    }\n  }], [{\n    key: \"getInstance\",\n    value: function getInstance() {\n      if (!GestureHandlerOrchestrator.instance) {\n        GestureHandlerOrchestrator.instance = new GestureHandlerOrchestrator();\n      }\n      return GestureHandlerOrchestrator.instance;\n    }\n  }]);\n}();\nexport { GestureHandlerOrchestrator as default };\n_defineProperty(GestureHandlerOrchestrator, \"instance\", void 0);","map":{"version":3,"names":["PointerType","State","PointerTracker","GestureHandlerOrchestrator","_classCallCheck","_defineProperty","Set","_createClass","key","value","scheduleFinishedHandlersCleanup","handlingChangeSemaphore","cleanupFinishedHandlers","cleanHandler","handler","reset","setActive","setAwaiting","setActivationIndex","Number","MAX_VALUE","removeHandlerFromOrchestrator","indexInGestureHandlers","gestureHandlers","indexOf","indexInAwaitingHandlers","awaitingHandlers","splice","awaitingHandlersTags","delete","getTag","handlersToRemove","i","length","isFinished","getState","isAwaiting","add","filter","has","hasOtherHandlerToWaitFor","_this","hasToWaitFor","otherHandler","shouldHandlerWaitForOther","some","shouldBeCancelledByFinishedHandler","_this2","shouldBeCancelled","END","tryActivate","cancel","addAwaitingHandler","handlerState","CANCELLED","FAILED","shouldActivate","makeActive","ACTIVE","fail","BEGAN","_this3","shouldBeCancelledBy","shouldHandlerBeCancelledBy","cleanupAwaitingHandlers","_this4","shouldWait","_iterator","_createForOfIteratorHelperLoose","_step","done","onHandlerStateChange","newState","oldState","sendIfDisabled","isEnabled","_iterator2","_step2","sendEvent","isActive","UNDETERMINED","includes","currentState","setShouldResetProgress","activationIndex","_iterator3","_step3","push","recordHandlerIfNotPresent","MAX_SAFE_INTEGER","shouldWaitForHandlerFailure","shouldRequireToWaitForFailure","canRunSimultaneously","gh1","gh2","shouldRecognizeSimultaneously","shouldBeCancelledByOther","handlerPointers","getTrackedPointersID","otherPointers","shareCommonPointers","getDelegate","getView","checkOverlap","isPointerWithinBothBounds","pointer","handlerX","getTracker","getLastX","handlerY","getLastY","point","x","y","isPointerInBounds","state","cancelMouseAndPenGestures","currentHandler","forEach","getPointerType","MOUSE","STYLUS","resetTracker","getInstance","instance","default"],"sources":["/Users/diegollull/Desktop/Uandes/8vo_semestre/APPS/ proyecto-del-curso-llull-zarate /hybrid-frontend/node_modules/react-native-gesture-handler/lib/module/web/tools/GestureHandlerOrchestrator.ts"],"sourcesContent":["import { PointerType } from '../../PointerType';\nimport { State } from '../../State';\n\nimport type IGestureHandler from '../handlers/IGestureHandler';\nimport PointerTracker from './PointerTracker';\n\nexport default class GestureHandlerOrchestrator {\n  private static instance: GestureHandlerOrchestrator;\n\n  private gestureHandlers: IGestureHandler[] = [];\n  private awaitingHandlers: IGestureHandler[] = [];\n  private awaitingHandlersTags: Set<number> = new Set();\n\n  private handlingChangeSemaphore = 0;\n  private activationIndex = 0;\n\n  // Private beacuse of Singleton\n  // eslint-disable-next-line no-useless-constructor, @typescript-eslint/no-empty-function\n  private constructor() {}\n\n  private scheduleFinishedHandlersCleanup(): void {\n    if (this.handlingChangeSemaphore === 0) {\n      this.cleanupFinishedHandlers();\n    }\n  }\n\n  private cleanHandler(handler: IGestureHandler): void {\n    handler.reset();\n    handler.setActive(false);\n    handler.setAwaiting(false);\n    handler.setActivationIndex(Number.MAX_VALUE);\n  }\n\n  public removeHandlerFromOrchestrator(handler: IGestureHandler): void {\n    const indexInGestureHandlers = this.gestureHandlers.indexOf(handler);\n    const indexInAwaitingHandlers = this.awaitingHandlers.indexOf(handler);\n\n    if (indexInGestureHandlers >= 0) {\n      this.gestureHandlers.splice(indexInGestureHandlers, 1);\n    }\n\n    if (indexInAwaitingHandlers >= 0) {\n      this.awaitingHandlers.splice(indexInAwaitingHandlers, 1);\n      this.awaitingHandlersTags.delete(handler.getTag());\n    }\n  }\n\n  private cleanupFinishedHandlers(): void {\n    const handlersToRemove = new Set<IGestureHandler>();\n\n    for (let i = this.gestureHandlers.length - 1; i >= 0; --i) {\n      const handler = this.gestureHandlers[i];\n\n      if (this.isFinished(handler.getState()) && !handler.isAwaiting()) {\n        this.cleanHandler(handler);\n        handlersToRemove.add(handler);\n      }\n    }\n\n    this.gestureHandlers = this.gestureHandlers.filter(\n      (handler) => !handlersToRemove.has(handler)\n    );\n  }\n\n  private hasOtherHandlerToWaitFor(handler: IGestureHandler): boolean {\n    const hasToWaitFor = (otherHandler: IGestureHandler) => {\n      return (\n        !this.isFinished(otherHandler.getState()) &&\n        this.shouldHandlerWaitForOther(handler, otherHandler)\n      );\n    };\n\n    return this.gestureHandlers.some(hasToWaitFor);\n  }\n\n  private shouldBeCancelledByFinishedHandler(\n    handler: IGestureHandler\n  ): boolean {\n    const shouldBeCancelled = (otherHandler: IGestureHandler) => {\n      return (\n        this.shouldHandlerWaitForOther(handler, otherHandler) &&\n        otherHandler.getState() === State.END\n      );\n    };\n\n    return this.gestureHandlers.some(shouldBeCancelled);\n  }\n\n  private tryActivate(handler: IGestureHandler): void {\n    if (this.shouldBeCancelledByFinishedHandler(handler)) {\n      handler.cancel();\n      return;\n    }\n\n    if (this.hasOtherHandlerToWaitFor(handler)) {\n      this.addAwaitingHandler(handler);\n      return;\n    }\n\n    const handlerState = handler.getState();\n\n    if (handlerState === State.CANCELLED || handlerState === State.FAILED) {\n      return;\n    }\n\n    if (this.shouldActivate(handler)) {\n      this.makeActive(handler);\n      return;\n    }\n\n    if (handlerState === State.ACTIVE) {\n      handler.fail();\n      return;\n    }\n\n    if (handlerState === State.BEGAN) {\n      handler.cancel();\n    }\n  }\n\n  private shouldActivate(handler: IGestureHandler): boolean {\n    const shouldBeCancelledBy = (otherHandler: IGestureHandler) => {\n      return this.shouldHandlerBeCancelledBy(handler, otherHandler);\n    };\n\n    return !this.gestureHandlers.some(shouldBeCancelledBy);\n  }\n\n  private cleanupAwaitingHandlers(handler: IGestureHandler): void {\n    const shouldWait = (otherHandler: IGestureHandler) => {\n      return (\n        !otherHandler.isAwaiting() &&\n        this.shouldHandlerWaitForOther(otherHandler, handler)\n      );\n    };\n\n    for (const otherHandler of this.awaitingHandlers) {\n      if (shouldWait(otherHandler)) {\n        this.cleanHandler(otherHandler);\n        this.awaitingHandlersTags.delete(otherHandler.getTag());\n      }\n    }\n\n    this.awaitingHandlers = this.awaitingHandlers.filter((otherHandler) =>\n      this.awaitingHandlersTags.has(otherHandler.getTag())\n    );\n  }\n\n  public onHandlerStateChange(\n    handler: IGestureHandler,\n    newState: State,\n    oldState: State,\n    sendIfDisabled?: boolean\n  ): void {\n    if (!handler.isEnabled() && !sendIfDisabled) {\n      return;\n    }\n\n    this.handlingChangeSemaphore += 1;\n\n    if (this.isFinished(newState)) {\n      for (const otherHandler of this.awaitingHandlers) {\n        if (\n          !this.shouldHandlerWaitForOther(otherHandler, handler) ||\n          !this.awaitingHandlersTags.has(otherHandler.getTag())\n        ) {\n          continue;\n        }\n\n        if (newState !== State.END) {\n          this.tryActivate(otherHandler);\n          continue;\n        }\n\n        otherHandler.cancel();\n\n        if (otherHandler.getState() === State.END) {\n          // Handle edge case, where discrete gestures end immediately after activation thus\n          // their state is set to END and when the gesture they are waiting for activates they\n          // should be cancelled, however `cancel` was never sent as gestures were already in the END state.\n          // Send synthetic BEGAN -> CANCELLED to properly handle JS logic\n          otherHandler.sendEvent(State.CANCELLED, State.BEGAN);\n        }\n\n        otherHandler.setAwaiting(false);\n      }\n    }\n\n    if (newState === State.ACTIVE) {\n      this.tryActivate(handler);\n    } else if (oldState === State.ACTIVE || oldState === State.END) {\n      if (handler.isActive()) {\n        handler.sendEvent(newState, oldState);\n      } else if (\n        oldState === State.ACTIVE &&\n        (newState === State.CANCELLED || newState === State.FAILED)\n      ) {\n        handler.sendEvent(newState, State.BEGAN);\n      }\n    } else if (\n      oldState !== State.UNDETERMINED ||\n      newState !== State.CANCELLED\n    ) {\n      handler.sendEvent(newState, oldState);\n    }\n\n    this.handlingChangeSemaphore -= 1;\n\n    this.scheduleFinishedHandlersCleanup();\n\n    if (!this.awaitingHandlers.includes(handler)) {\n      this.cleanupAwaitingHandlers(handler);\n    }\n  }\n\n  private makeActive(handler: IGestureHandler): void {\n    const currentState = handler.getState();\n\n    handler.setActive(true);\n    handler.setShouldResetProgress(true);\n    handler.setActivationIndex(this.activationIndex++);\n\n    for (let i = this.gestureHandlers.length - 1; i >= 0; --i) {\n      if (this.shouldHandlerBeCancelledBy(this.gestureHandlers[i], handler)) {\n        this.gestureHandlers[i].cancel();\n      }\n    }\n\n    for (const otherHandler of this.awaitingHandlers) {\n      if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n        otherHandler.setAwaiting(false);\n      }\n    }\n\n    handler.sendEvent(State.ACTIVE, State.BEGAN);\n\n    if (currentState !== State.ACTIVE) {\n      handler.sendEvent(State.END, State.ACTIVE);\n      if (currentState !== State.END) {\n        handler.sendEvent(State.UNDETERMINED, State.END);\n      }\n    }\n\n    if (!handler.isAwaiting()) {\n      return;\n    }\n\n    handler.setAwaiting(false);\n\n    this.awaitingHandlers = this.awaitingHandlers.filter(\n      (otherHandler) => otherHandler !== handler\n    );\n  }\n\n  private addAwaitingHandler(handler: IGestureHandler): void {\n    if (this.awaitingHandlers.includes(handler)) {\n      return;\n    }\n\n    this.awaitingHandlers.push(handler);\n    this.awaitingHandlersTags.add(handler.getTag());\n\n    handler.setAwaiting(true);\n    handler.setActivationIndex(this.activationIndex++);\n  }\n\n  public recordHandlerIfNotPresent(handler: IGestureHandler): void {\n    if (this.gestureHandlers.includes(handler)) {\n      return;\n    }\n\n    this.gestureHandlers.push(handler);\n\n    handler.setActive(false);\n    handler.setAwaiting(false);\n    handler.setActivationIndex(Number.MAX_SAFE_INTEGER);\n  }\n\n  private shouldHandlerWaitForOther(\n    handler: IGestureHandler,\n    otherHandler: IGestureHandler\n  ): boolean {\n    return (\n      handler !== otherHandler &&\n      (handler.shouldWaitForHandlerFailure(otherHandler) ||\n        otherHandler.shouldRequireToWaitForFailure(handler))\n    );\n  }\n\n  private canRunSimultaneously(\n    gh1: IGestureHandler,\n    gh2: IGestureHandler\n  ): boolean {\n    return (\n      gh1 === gh2 ||\n      gh1.shouldRecognizeSimultaneously(gh2) ||\n      gh2.shouldRecognizeSimultaneously(gh1)\n    );\n  }\n\n  private shouldHandlerBeCancelledBy(\n    handler: IGestureHandler,\n    otherHandler: IGestureHandler\n  ): boolean {\n    if (this.canRunSimultaneously(handler, otherHandler)) {\n      return false;\n    }\n\n    if (handler.isAwaiting() || handler.getState() === State.ACTIVE) {\n      // For now it always returns false\n      return handler.shouldBeCancelledByOther(otherHandler);\n    }\n\n    const handlerPointers: number[] = handler.getTrackedPointersID();\n    const otherPointers: number[] = otherHandler.getTrackedPointersID();\n\n    if (\n      !PointerTracker.shareCommonPointers(handlerPointers, otherPointers) &&\n      handler.getDelegate().getView() !== otherHandler.getDelegate().getView()\n    ) {\n      return this.checkOverlap(handler, otherHandler);\n    }\n\n    return true;\n  }\n\n  private checkOverlap(\n    handler: IGestureHandler,\n    otherHandler: IGestureHandler\n  ): boolean {\n    // If handlers don't have common pointers, default return value is false.\n    // However, if at least on pointer overlaps with both handlers, we return true\n    // This solves issue in overlapping parents example\n\n    // TODO: Find better way to handle that issue, for example by activation order and handler cancelling\n\n    const isPointerWithinBothBounds = (pointer: number) => {\n      const handlerX: number = handler.getTracker().getLastX(pointer);\n      const handlerY: number = handler.getTracker().getLastY(pointer);\n\n      const point = {\n        x: handlerX,\n        y: handlerY,\n      };\n\n      return (\n        handler.getDelegate().isPointerInBounds(point) &&\n        otherHandler.getDelegate().isPointerInBounds(point)\n      );\n    };\n\n    const handlerPointers: number[] = handler.getTrackedPointersID();\n    const otherPointers: number[] = otherHandler.getTrackedPointersID();\n\n    return (\n      handlerPointers.some(isPointerWithinBothBounds) ||\n      otherPointers.some(isPointerWithinBothBounds)\n    );\n  }\n\n  private isFinished(state: State): boolean {\n    return (\n      state === State.END || state === State.FAILED || state === State.CANCELLED\n    );\n  }\n\n  // This function is called when handler receives touchdown event\n  // If handler is using mouse or pen as a pointer and any handler receives touch event,\n  // mouse/pen event dissappears - it doesn't send onPointerCancel nor onPointerUp (and others)\n  // This became a problem because handler was left at active state without any signal to end or fail\n  // To handle this, when new touch event is received, we loop through active handlers and check which type of\n  // pointer they're using. If there are any handler with mouse/pen as a pointer, we cancel them\n  public cancelMouseAndPenGestures(currentHandler: IGestureHandler): void {\n    this.gestureHandlers.forEach((handler: IGestureHandler) => {\n      if (\n        handler.getPointerType() !== PointerType.MOUSE &&\n        handler.getPointerType() !== PointerType.STYLUS\n      ) {\n        return;\n      }\n\n      if (handler !== currentHandler) {\n        handler.cancel();\n      } else {\n        // Handler that received touch event should have its pointer tracker reset\n        // This allows handler to smoothly change from mouse/pen to touch\n        // The drawback is, that when we try to use mouse/pen one more time, it doesn't send onPointerDown at the first time\n        // so it is required to click two times to get handler to work\n        //\n        // However, handler will receive manually created onPointerEnter that is triggered in EventManager in onPointerMove method.\n        // There may be possibility to use that fact to make handler respond properly to first mouse click\n        handler.getTracker().resetTracker();\n      }\n    });\n  }\n\n  public static getInstance(): GestureHandlerOrchestrator {\n    if (!GestureHandlerOrchestrator.instance) {\n      GestureHandlerOrchestrator.instance = new GestureHandlerOrchestrator();\n    }\n\n    return GestureHandlerOrchestrator.instance;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}