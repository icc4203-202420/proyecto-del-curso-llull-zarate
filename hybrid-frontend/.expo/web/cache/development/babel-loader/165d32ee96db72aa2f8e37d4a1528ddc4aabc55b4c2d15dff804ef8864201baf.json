{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar _resolveHref = function resolveHref(href) {\n  var _href$pathname;\n  if (typeof href === 'string') {\n    return _resolveHref({\n      pathname: href != null ? href : ''\n    });\n  }\n  var path = (_href$pathname = href.pathname) != null ? _href$pathname : '';\n  if (!(href != null && href.params)) {\n    return path;\n  }\n  var _createQualifiedPathn = createQualifiedPathname(path, _objectSpread({}, href.params)),\n    pathname = _createQualifiedPathn.pathname,\n    params = _createQualifiedPathn.params;\n  var paramsString = createQueryParams(params);\n  return pathname + (paramsString ? \"?\" + paramsString : '');\n};\nexport { _resolveHref as resolveHref };\nfunction createQualifiedPathname(pathname, params) {\n  for (var _i = 0, _Object$entries = Object.entries(params); _i < _Object$entries.length; _i++) {\n    var _ref = _Object$entries[_i];\n    var _ref2 = _slicedToArray(_ref, 2);\n    var key = _ref2[0];\n    var _ref2$ = _ref2[1];\n    var value = _ref2$ === void 0 ? '' : _ref2$;\n    var dynamicKey = \"[\" + key + \"]\";\n    var deepDynamicKey = \"[...\" + key + \"]\";\n    if (pathname.includes(dynamicKey)) {\n      pathname = pathname.replace(dynamicKey, encodeParam(value));\n    } else if (pathname.includes(deepDynamicKey)) {\n      pathname = pathname.replace(deepDynamicKey, encodeParam(value));\n    } else {\n      continue;\n    }\n    delete params[key];\n  }\n  return {\n    pathname: pathname,\n    params: params\n  };\n}\nfunction encodeParam(param) {\n  if (Array.isArray(param)) {\n    return param.map(function (p) {\n      return encodeParam(p);\n    }).join('/');\n  }\n  return encodeURIComponent(param.toString());\n}\nfunction createQueryParams(params) {\n  return Object.entries(params).filter(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n      value = _ref4[1];\n    return value != null;\n  }).map(function (_ref5) {\n    var _ref6 = _slicedToArray(_ref5, 2),\n      key = _ref6[0],\n      value = _ref6[1];\n    return key + \"=\" + encodeURIComponent(value.toString());\n  }).join('&');\n}","map":{"version":3,"names":["resolveHref","href","_href$pathname","pathname","path","params","_createQualifiedPathn","createQualifiedPathname","_objectSpread","paramsString","createQueryParams","_resolveHref","_i","_Object$entries","Object","entries","length","_ref","_ref2","_slicedToArray","key","_ref2$","value","dynamicKey","deepDynamicKey","includes","replace","encodeParam","param","Array","isArray","map","p","join","encodeURIComponent","toString","filter","_ref3","_ref4","_ref5","_ref6"],"sources":["/Users/diegollull/Desktop/Uandes/8vo_semestre/APPS/ proyecto-del-curso-llull-zarate /hybrid-frontend/node_modules/expo-router/src/link/href.ts"],"sourcesContent":["export type Href = string | HrefObject;\n\nexport interface HrefObject {\n  /** Path representing the selected route `/[id]`. */\n  pathname?: string;\n  /** Query parameters for the path. */\n  params?: Record<string, any>;\n}\n\n/** Resolve an href object into a fully qualified, relative href. */\nexport const resolveHref = (href: Href): string => {\n  if (typeof href === 'string') {\n    return resolveHref({ pathname: href ?? '' });\n  }\n  const path = href.pathname ?? '';\n  if (!href?.params) {\n    return path;\n  }\n  const { pathname, params } = createQualifiedPathname(path, {\n    ...href.params,\n  });\n  const paramsString = createQueryParams(params);\n  return pathname + (paramsString ? `?${paramsString}` : '');\n};\n\nfunction createQualifiedPathname(\n  pathname: string,\n  params: Record<string, any>\n): Omit<Required<HrefObject>, 'query'> {\n  for (const [key, value = ''] of Object.entries(params)) {\n    const dynamicKey = `[${key}]`;\n    const deepDynamicKey = `[...${key}]`;\n    if (pathname.includes(dynamicKey)) {\n      pathname = pathname.replace(dynamicKey, encodeParam(value));\n    } else if (pathname.includes(deepDynamicKey)) {\n      pathname = pathname.replace(deepDynamicKey, encodeParam(value));\n    } else {\n      continue;\n    }\n\n    delete params[key];\n  }\n  return { pathname, params };\n}\n\nfunction encodeParam(param: any): string {\n  if (Array.isArray(param)) {\n    return param.map((p) => encodeParam(p)).join('/');\n  }\n\n  return encodeURIComponent(param.toString());\n}\n\nfunction createQueryParams(params: Record<string, any>): string {\n  return (\n    Object.entries(params)\n      // Allow nullish params\n      .filter(([, value]) => value != null)\n      .map(([key, value]) => `${key}=${encodeURIComponent(value.toString())}`)\n      .join('&')\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}