{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _createForOfIteratorHelperLoose(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nimport { useNavigationContainerRef } from '@react-navigation/native';\nimport { useSyncExternalStore, useMemo, Fragment } from 'react';\nimport { canGoBack, goBack, linkTo, push, replace, setParams } from \"./routing\";\nimport { getSortedRoutes } from \"./sort-routes\";\nimport { getRouteInfoFromState } from \"../LocationProvider\";\nimport { deepEqual, getPathDataFromState } from \"../fork/getPathFromState\";\nimport { getLinkingConfig } from \"../getLinkingConfig\";\nimport { getRoutes } from \"../getRoutes\";\nimport { getQualifiedRouteComponent } from \"../useScreens\";\nimport { _internal_maybeHideAsync } from \"../views/Splash\";\nexport var RouterStore = function () {\n  function RouterStore() {\n    var _this = this;\n    _classCallCheck(this, RouterStore);\n    this.hasAttemptedToHideSplash = false;\n    this.rootStateSubscribers = new Set();\n    this.storeSubscribers = new Set();\n    this.linkTo = linkTo.bind(this);\n    this.getSortedRoutes = getSortedRoutes.bind(this);\n    this.goBack = goBack.bind(this);\n    this.canGoBack = canGoBack.bind(this);\n    this.push = push.bind(this);\n    this.replace = replace.bind(this);\n    this.setParams = setParams.bind(this);\n    this.subscribeToRootState = function (subscriber) {\n      _this.rootStateSubscribers.add(subscriber);\n      return function () {\n        return _this.rootStateSubscribers.delete(subscriber);\n      };\n    };\n    this.subscribeToStore = function (subscriber) {\n      _this.storeSubscribers.add(subscriber);\n      return function () {\n        return _this.storeSubscribers.delete(subscriber);\n      };\n    };\n    this.snapshot = function () {\n      return _this;\n    };\n    this.rootStateSnapshot = function () {\n      return _this.rootState;\n    };\n    this.routeInfoSnapshot = function () {\n      return _this.routeInfo;\n    };\n  }\n  return _createClass(RouterStore, [{\n    key: \"initialize\",\n    value: function initialize(context, navigationRef, initialLocation) {\n      var _this$navigationRefSu,\n        _this2 = this;\n      this.initialState = undefined;\n      this.rootState = undefined;\n      this.nextState = undefined;\n      this.routeInfo = undefined;\n      this.linking = undefined;\n      (_this$navigationRefSu = this.navigationRefSubscription) == null ? void 0 : _this$navigationRefSu.call(this);\n      this.rootStateSubscribers.clear();\n      this.storeSubscribers.clear();\n      this.routeNode = getRoutes(context);\n      this.rootComponent = this.routeNode ? getQualifiedRouteComponent(this.routeNode) : Fragment;\n      if (!this.routeNode && process.env.NODE_ENV === 'production') {\n        throw new Error('No routes found');\n      }\n      this.navigationRef = navigationRef;\n      if (this.routeNode) {\n        this.linking = getLinkingConfig(this.routeNode);\n        if (initialLocation) {\n          var _this$linking$getStat, _this$linking;\n          this.linking.getInitialURL = function () {\n            return initialLocation.toString();\n          };\n          this.initialState = (_this$linking$getStat = (_this$linking = this.linking).getStateFromPath) == null ? void 0 : _this$linking$getStat.call(_this$linking, initialLocation.pathname + initialLocation.search, this.linking.config);\n        }\n      }\n      if (this.initialState) {\n        this.rootState = this.initialState;\n        this.routeInfo = this.getRouteInfo(this.initialState);\n      } else {\n        this.routeInfo = {\n          unstable_globalHref: '',\n          pathname: '',\n          params: {},\n          segments: []\n        };\n      }\n      this.navigationRefSubscription = navigationRef.addListener('state', function (data) {\n        var state = data.data.state;\n        if (!_this2.hasAttemptedToHideSplash) {\n          _this2.hasAttemptedToHideSplash = true;\n          requestAnimationFrame(function () {\n            return _internal_maybeHideAsync();\n          });\n        }\n        var shouldUpdateSubscribers = _this2.nextState === state;\n        _this2.nextState = undefined;\n        if (state && state !== _this2.rootState) {\n          store.updateState(state, undefined);\n          shouldUpdateSubscribers = true;\n        }\n        if (shouldUpdateSubscribers) {\n          for (var _iterator = _createForOfIteratorHelperLoose(_this2.rootStateSubscribers), _step; !(_step = _iterator()).done;) {\n            var subscriber = _step.value;\n            subscriber();\n          }\n        }\n      });\n      for (var _iterator2 = _createForOfIteratorHelperLoose(this.storeSubscribers), _step2; !(_step2 = _iterator2()).done;) {\n        var subscriber = _step2.value;\n        subscriber();\n      }\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(state) {\n      var nextState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : state;\n      store.rootState = state;\n      store.nextState = nextState;\n      var nextRouteInfo = store.getRouteInfo(state);\n      if (!deepEqual(this.routeInfo, nextRouteInfo)) {\n        store.routeInfo = nextRouteInfo;\n      }\n    }\n  }, {\n    key: \"getRouteInfo\",\n    value: function getRouteInfo(state) {\n      var _this3 = this;\n      return getRouteInfoFromState(function (state, asPath) {\n        var _this3$linking;\n        return getPathDataFromState(state, _objectSpread(_objectSpread({\n          screens: []\n        }, (_this3$linking = _this3.linking) == null ? void 0 : _this3$linking.config), {}, {\n          preserveDynamicRoutes: asPath,\n          preserveGroups: asPath\n        }));\n      }, state);\n    }\n  }, {\n    key: \"shouldShowTutorial\",\n    value: function shouldShowTutorial() {\n      return !this.routeNode && process.env.NODE_ENV === 'development';\n    }\n  }]);\n}();\nexport var store = new RouterStore();\nexport function useExpoRouter() {\n  return useSyncExternalStore(store.subscribeToStore, store.snapshot, store.snapshot);\n}\nfunction syncStoreRootState() {\n  if (store.navigationRef.isReady()) {\n    var currentState = store.navigationRef.getRootState();\n    if (store.rootState !== currentState) {\n      store.updateState(currentState);\n    }\n  }\n}\nexport function useStoreRootState() {\n  syncStoreRootState();\n  return useSyncExternalStore(store.subscribeToRootState, store.rootStateSnapshot, store.rootStateSnapshot);\n}\nexport function useStoreRouteInfo() {\n  syncStoreRootState();\n  return useSyncExternalStore(store.subscribeToRootState, store.routeInfoSnapshot, store.routeInfoSnapshot);\n}\nexport function useInitializeExpoRouter(context, initialLocation) {\n  var navigationRef = useNavigationContainerRef();\n  useMemo(function () {\n    return store.initialize(context, navigationRef, initialLocation);\n  }, [context, initialLocation]);\n  useExpoRouter();\n  return store;\n}","map":{"version":3,"names":["useNavigationContainerRef","useSyncExternalStore","useMemo","Fragment","canGoBack","goBack","linkTo","push","replace","setParams","getSortedRoutes","getRouteInfoFromState","deepEqual","getPathDataFromState","getLinkingConfig","getRoutes","getQualifiedRouteComponent","_internal_maybeHideAsync","RouterStore","_this","_classCallCheck","hasAttemptedToHideSplash","rootStateSubscribers","Set","storeSubscribers","bind","subscribeToRootState","subscriber","add","delete","subscribeToStore","snapshot","rootStateSnapshot","rootState","routeInfoSnapshot","routeInfo","_createClass","key","value","initialize","context","navigationRef","initialLocation","_this$navigationRefSu","_this2","initialState","undefined","nextState","linking","navigationRefSubscription","call","clear","routeNode","rootComponent","process","env","NODE_ENV","Error","_this$linking$getStat","_this$linking","getInitialURL","toString","getStateFromPath","pathname","search","config","getRouteInfo","unstable_globalHref","params","segments","addListener","data","state","requestAnimationFrame","shouldUpdateSubscribers","store","updateState","_iterator","_createForOfIteratorHelperLoose","_step","done","_iterator2","_step2","arguments","length","nextRouteInfo","_this3","asPath","_this3$linking","_objectSpread","screens","preserveDynamicRoutes","preserveGroups","shouldShowTutorial","useExpoRouter","syncStoreRootState","isReady","currentState","getRootState","useStoreRootState","useStoreRouteInfo","useInitializeExpoRouter"],"sources":["/Users/diegollull/Desktop/Uandes/8vo_semestre/APPS/ proyecto-del-curso-llull-zarate /hybrid-frontend/node_modules/expo-router/src/global-state/router-store.tsx"],"sourcesContent":["import {\n  NavigationContainerRefWithCurrent,\n  getPathFromState,\n  useNavigationContainerRef,\n} from '@react-navigation/native';\nimport { useSyncExternalStore, useMemo, ComponentType, Fragment } from 'react';\n\nimport { canGoBack, goBack, linkTo, push, replace, setParams } from './routing';\nimport { getSortedRoutes } from './sort-routes';\nimport { UrlObject, getRouteInfoFromState } from '../LocationProvider';\nimport { RouteNode } from '../Route';\nimport { deepEqual, getPathDataFromState } from '../fork/getPathFromState';\nimport { ResultState } from '../fork/getStateFromPath';\nimport { ExpoLinkingOptions, getLinkingConfig } from '../getLinkingConfig';\nimport { getRoutes } from '../getRoutes';\nimport { RequireContext } from '../types';\nimport { getQualifiedRouteComponent } from '../useScreens';\nimport { _internal_maybeHideAsync } from '../views/Splash';\n\n/**\n * This is the global state for the router. It is used to keep track of the current route, and to provide a way to navigate to other routes.\n *\n * There should only be one instance of this class and be initialized via `useInitializeExpoRouter`\n */\nexport class RouterStore {\n  routeNode!: RouteNode | null;\n  rootComponent!: ComponentType;\n  linking: ExpoLinkingOptions | undefined;\n  private hasAttemptedToHideSplash: boolean = false;\n\n  initialState: ResultState | undefined;\n  rootState: ResultState | undefined;\n  nextState: ResultState | undefined;\n  routeInfo?: UrlObject | undefined;\n\n  navigationRef!: NavigationContainerRefWithCurrent<ReactNavigation.RootParamList>;\n  navigationRefSubscription!: () => void;\n\n  rootStateSubscribers = new Set<() => void>();\n  storeSubscribers = new Set<() => void>();\n\n  linkTo = linkTo.bind(this);\n  getSortedRoutes = getSortedRoutes.bind(this);\n  goBack = goBack.bind(this);\n  canGoBack = canGoBack.bind(this);\n  push = push.bind(this);\n  replace = replace.bind(this);\n  setParams = setParams.bind(this);\n\n  initialize(\n    context: RequireContext,\n    navigationRef: NavigationContainerRefWithCurrent<ReactNavigation.RootParamList>,\n    initialLocation?: URL\n  ) {\n    // Clean up any previous state\n    this.initialState = undefined;\n    this.rootState = undefined;\n    this.nextState = undefined;\n    this.routeInfo = undefined;\n    this.linking = undefined;\n    this.navigationRefSubscription?.();\n    this.rootStateSubscribers.clear();\n    this.storeSubscribers.clear();\n\n    this.routeNode = getRoutes(context);\n\n    this.rootComponent = this.routeNode ? getQualifiedRouteComponent(this.routeNode) : Fragment;\n\n    // Only error in production, in development we will show the onboarding screen\n    if (!this.routeNode && process.env.NODE_ENV === 'production') {\n      throw new Error('No routes found');\n    }\n\n    this.navigationRef = navigationRef;\n\n    if (this.routeNode) {\n      this.linking = getLinkingConfig(this.routeNode!);\n\n      if (initialLocation) {\n        this.linking.getInitialURL = () => initialLocation.toString();\n        this.initialState = this.linking.getStateFromPath?.(\n          initialLocation.pathname + initialLocation.search,\n          this.linking.config\n        );\n      }\n    }\n\n    // There is no routeNode, so we will be showing the onboarding screen\n    // In the meantime, just mock the routeInfo\n    if (this.initialState) {\n      this.rootState = this.initialState;\n      this.routeInfo = this.getRouteInfo(this.initialState);\n    } else {\n      this.routeInfo = {\n        unstable_globalHref: '',\n        pathname: '',\n        params: {},\n        segments: [],\n      };\n    }\n\n    /**\n     * Counter intuitively - this fires AFTER both React Navigations state change and the subsequent paint.\n     * This poses a couple of issues for Expo Router,\n     *   - Ensuring hooks (e.g. useSearchParams()) have data in the initial render\n     *   - Reacting to state changes after a navigation event\n     *\n     * This is why the initial render renders a Fragment and we wait until `onReady()` is called\n     * Additionally, some hooks compare the state from both the store and the navigationRef. If the store it stale,\n     * that hooks will manually update the store.\n     *\n     */\n    this.navigationRefSubscription = navigationRef.addListener('state', (data) => {\n      const state = data.data.state as ResultState;\n\n      if (!this.hasAttemptedToHideSplash) {\n        this.hasAttemptedToHideSplash = true;\n        // NOTE(EvanBacon): `navigationRef.isReady` is sometimes not true when state is called initially.\n        requestAnimationFrame(() => _internal_maybeHideAsync());\n      }\n\n      let shouldUpdateSubscribers = this.nextState === state;\n      this.nextState = undefined;\n\n      // This can sometimes be undefined when an error is thrown in the Root Layout Route.\n      // Additionally that state may already equal the rootState if it was updated within a hook\n      if (state && state !== this.rootState) {\n        store.updateState(state, undefined);\n        shouldUpdateSubscribers = true;\n      }\n\n      // If the state has changed, or was changed inside a hook we need to update the subscribers\n      if (shouldUpdateSubscribers) {\n        for (const subscriber of this.rootStateSubscribers) {\n          subscriber();\n        }\n      }\n    });\n\n    for (const subscriber of this.storeSubscribers) {\n      subscriber();\n    }\n  }\n\n  updateState(state: ResultState, nextState = state) {\n    store.rootState = state;\n    store.nextState = nextState;\n\n    const nextRouteInfo = store.getRouteInfo(state);\n\n    if (!deepEqual(this.routeInfo, nextRouteInfo)) {\n      store.routeInfo = nextRouteInfo;\n    }\n  }\n\n  getRouteInfo(state: ResultState) {\n    return getRouteInfoFromState(\n      (state: Parameters<typeof getPathFromState>[0], asPath: boolean) => {\n        return getPathDataFromState(state, {\n          screens: [],\n          ...this.linking?.config,\n          preserveDynamicRoutes: asPath,\n          preserveGroups: asPath,\n        });\n      },\n      state\n    );\n  }\n\n  // This is only used in development, to show the onboarding screen\n  // In production we should have errored during the initialization\n  shouldShowTutorial() {\n    return !this.routeNode && process.env.NODE_ENV === 'development';\n  }\n\n  /** Make sure these are arrow functions so `this` is correctly bound */\n  subscribeToRootState = (subscriber: () => void) => {\n    this.rootStateSubscribers.add(subscriber);\n    return () => this.rootStateSubscribers.delete(subscriber);\n  };\n  subscribeToStore = (subscriber: () => void) => {\n    this.storeSubscribers.add(subscriber);\n    return () => this.storeSubscribers.delete(subscriber);\n  };\n  snapshot = () => {\n    return this;\n  };\n  rootStateSnapshot = () => {\n    return this.rootState!;\n  };\n  routeInfoSnapshot = () => {\n    return this.routeInfo!;\n  };\n}\n\nexport const store = new RouterStore();\n\nexport function useExpoRouter() {\n  return useSyncExternalStore(store.subscribeToStore, store.snapshot, store.snapshot);\n}\n\nfunction syncStoreRootState() {\n  if (store.navigationRef.isReady()) {\n    const currentState = store.navigationRef.getRootState() as unknown as ResultState;\n\n    if (store.rootState !== currentState) {\n      store.updateState(currentState);\n    }\n  }\n}\n\nexport function useStoreRootState() {\n  syncStoreRootState();\n  return useSyncExternalStore(\n    store.subscribeToRootState,\n    store.rootStateSnapshot,\n    store.rootStateSnapshot\n  );\n}\n\nexport function useStoreRouteInfo() {\n  syncStoreRootState();\n  return useSyncExternalStore(\n    store.subscribeToRootState,\n    store.routeInfoSnapshot,\n    store.routeInfoSnapshot\n  );\n}\n\nexport function useInitializeExpoRouter(context: RequireContext, initialLocation: URL | undefined) {\n  const navigationRef = useNavigationContainerRef();\n  useMemo(\n    () => store.initialize(context, navigationRef, initialLocation),\n    [context, initialLocation]\n  );\n  useExpoRouter();\n  return store;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}