{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport * as SplashModule from 'expo-splash-screen';\nimport { nanoid } from 'nanoid/non-secure';\nimport * as React from 'react';\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport { useDeprecated } from \"../useDeprecated\";\nvar globalStack = [];\nexport function SplashScreen() {\n  useGlobalSplash();\n  useDeprecated('The <SplashScreen /> component is deprecated. Use `SplashScreen.preventAutoHideAsync()` and `SplashScreen.hideAsync` from `expo-router` instead.');\n  return null;\n}\nfunction useGlobalSplash() {\n  var stack = React.useRef(null);\n  React.useEffect(function () {\n    stack.current = SplashScreen._pushEntry();\n    return function () {\n      if (stack.current) {\n        SplashScreen._popEntry(stack.current);\n      }\n    };\n  }, []);\n}\nSplashScreen.hideAsync = function () {\n  forceHideAsync();\n  globalStack.length = 0;\n};\nvar _userControlledAutoHideEnabled = false;\nvar _preventAutoHideAsyncInvoked = false;\nexport var _internal_preventAutoHideAsync = function _internal_preventAutoHideAsync() {\n  var _ErrorUtils;\n  if (_preventAutoHideAsyncInvoked) {\n    return;\n  }\n  _preventAutoHideAsyncInvoked = true;\n  if (Platform.OS !== 'web' && (_ErrorUtils = ErrorUtils) != null && _ErrorUtils.getGlobalHandler) {\n    var originalHandler = ErrorUtils.getGlobalHandler();\n    ErrorUtils.setGlobalHandler(function (error, isFatal) {\n      SplashScreen.hideAsync();\n      originalHandler(error, isFatal);\n    });\n  }\n  SplashModule.preventAutoHideAsync();\n};\nexport var _internal_maybeHideAsync = function _internal_maybeHideAsync() {\n  if (_userControlledAutoHideEnabled) {\n    return;\n  }\n  SplashScreen.hideAsync();\n};\nfunction forceHideAsync() {\n  return _regeneratorRuntime.async(function forceHideAsync$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        return _context.abrupt(\"return\", SplashModule.hideAsync().catch(function (error) {\n          if (_preventAutoHideAsyncInvoked && error.message.includes('No native splash screen registered for ')) {\n            return;\n          }\n          throw error;\n        }));\n      case 1:\n      case \"end\":\n        return _context.stop();\n    }\n  }, null, null, null, Promise);\n}\nSplashScreen.preventAutoHideAsync = function () {\n  _userControlledAutoHideEnabled = true;\n  _internal_preventAutoHideAsync();\n};\nSplashScreen._pushEntry = function () {\n  var entry = nanoid();\n  globalStack.push(entry);\n  SplashScreen.preventAutoHideAsync();\n  return entry;\n};\nSplashScreen._popEntry = function (entry) {\n  var index = globalStack.indexOf(entry);\n  if (index !== -1) {\n    globalStack.splice(index, 1);\n  }\n  if (globalStack.length === 0) {\n    SplashScreen.hideAsync();\n  }\n};","map":{"version":3,"names":["SplashModule","nanoid","React","Platform","useDeprecated","globalStack","SplashScreen","useGlobalSplash","stack","useRef","useEffect","current","_pushEntry","_popEntry","hideAsync","forceHideAsync","length","_userControlledAutoHideEnabled","_preventAutoHideAsyncInvoked","_internal_preventAutoHideAsync","_ErrorUtils","OS","ErrorUtils","getGlobalHandler","originalHandler","setGlobalHandler","error","isFatal","preventAutoHideAsync","_internal_maybeHideAsync","_regeneratorRuntime","async","forceHideAsync$","_context","prev","next","abrupt","catch","message","includes","stop","Promise","entry","push","index","indexOf","splice"],"sources":["/Users/diegollull/Desktop/Uandes/8vo_semestre/APPS/ proyecto-del-curso-llull-zarate /hybrid-frontend/node_modules/expo-router/src/views/Splash.tsx"],"sourcesContent":["import * as SplashModule from 'expo-splash-screen';\nimport { nanoid } from 'nanoid/non-secure';\nimport * as React from 'react';\nimport { Platform } from 'react-native';\n\nimport { useDeprecated } from '../useDeprecated';\n\nconst globalStack: string[] = [];\n\n/**\n * A stack based component for keeping the splash screen visible.\n * Useful for stacked requests that need to be completed before the app is ready.\n * After all instances have been unmounted, the splash screen will be hidden.\n *\n * @example\n * ```tsx\n * function App() {\n *   const [isLoading, setIsLoading] = React.useState(true);\n *\n *   if (isLoading) {\n *     return <SplashScreen />\n *   }\n *\n *   return <Text>Ready!</Text>\n * }\n * ```\n */\nexport function SplashScreen() {\n  useGlobalSplash();\n  useDeprecated(\n    'The <SplashScreen /> component is deprecated. Use `SplashScreen.preventAutoHideAsync()` and `SplashScreen.hideAsync` from `expo-router` instead.'\n  );\n  return null;\n}\n\nfunction useGlobalSplash() {\n  const stack = React.useRef<string | null>(null);\n\n  React.useEffect(() => {\n    // Create a stack entry on component mount\n    stack.current = SplashScreen._pushEntry();\n    return () => {\n      if (stack.current) {\n        // Update on component unmount\n        SplashScreen._popEntry(stack.current);\n      }\n    };\n  }, []);\n}\n\nSplashScreen.hideAsync = () => {\n  forceHideAsync();\n  globalStack.length = 0;\n};\n\nlet _userControlledAutoHideEnabled = false;\nlet _preventAutoHideAsyncInvoked = false;\n\n// Expo Router uses this internal method to ensure that we can detect if the user\n// has explicitly opted into preventing the splash screen from hiding. This means\n// they will also explicitly hide it. If they don't, we will hide it for them after\n// the navigation render completes.\nexport const _internal_preventAutoHideAsync = () => {\n  // Memoize, this should only be called once.\n  if (_preventAutoHideAsyncInvoked) {\n    return;\n  }\n  _preventAutoHideAsyncInvoked = true;\n  // Append error handling to ensure any uncaught exceptions result in the splash screen being hidden.\n  if (Platform.OS !== 'web' && ErrorUtils?.getGlobalHandler) {\n    const originalHandler = ErrorUtils.getGlobalHandler();\n    ErrorUtils.setGlobalHandler((error, isFatal) => {\n      SplashScreen.hideAsync();\n      originalHandler(error, isFatal);\n    });\n  }\n  SplashModule.preventAutoHideAsync();\n};\n\nexport const _internal_maybeHideAsync = () => {\n  // If the user has explicitly opted into preventing the splash screen from hiding,\n  // we should not hide it for them. This is often used for animated splash screens.\n  if (_userControlledAutoHideEnabled) {\n    return;\n  }\n  SplashScreen.hideAsync();\n};\n\nasync function forceHideAsync() {\n  return SplashModule.hideAsync().catch((error: any) => {\n    // Hide this very unfortunate error.\n    if (\n      // Only throw the error is something unexpected happened.\n      _preventAutoHideAsyncInvoked &&\n      error.message.includes('No native splash screen registered for ')\n    ) {\n      return;\n    }\n    throw error;\n  });\n}\n\nSplashScreen.preventAutoHideAsync = () => {\n  _userControlledAutoHideEnabled = true;\n  _internal_preventAutoHideAsync();\n};\n\nSplashScreen._pushEntry = (): any => {\n  const entry = nanoid();\n  globalStack.push(entry);\n  SplashScreen.preventAutoHideAsync();\n  return entry;\n};\n\nSplashScreen._popEntry = (entry: string) => {\n  const index = globalStack.indexOf(entry);\n  if (index !== -1) {\n    globalStack.splice(index, 1);\n  }\n  if (globalStack.length === 0) {\n    SplashScreen.hideAsync();\n  }\n};\n\n// TODO: Add some detection for if the splash screen is visible\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}