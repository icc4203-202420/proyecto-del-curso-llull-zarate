{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _createForOfIteratorHelperLoose(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nimport EXPO_ROUTER_IMPORT_MODE from \"./import-mode\";\nimport { getNameFromFilePath, matchDeepDynamicRouteName, matchDynamicName, matchGroupName, removeSupportedExtensions, stripGroupSegmentsFromPath, stripInvisibleSegmentsFromPath } from \"./matchers\";\nexport function getRecursiveTree(files) {\n  var tree = {\n    name: '',\n    children: [],\n    parents: [],\n    node: null\n  };\n  for (var _iterator = _createForOfIteratorHelperLoose(files), _step; !(_step = _iterator()).done;) {\n    var file = _step.value;\n    var parts = file.normalizedName.split('/');\n    var currentNode = tree;\n    var _loop = function _loop() {\n      var part = parts[i];\n      if (i === parts.length - 1 && part === '_layout') {\n        if (currentNode.node) {\n          var overwritten = currentNode.node.contextKey;\n          throw new Error(\"Higher priority Layout Route \\\"\" + file.contextKey + \"\\\" overriding redundant Layout Route \\\"\" + overwritten + \"\\\". Remove the Layout Route \\\"\" + overwritten + \"\\\" to fix this.\");\n        }\n        return 1;\n      }\n      var existing = currentNode.children.find(function (item) {\n        return item.name === part;\n      });\n      if (existing) {\n        currentNode = existing;\n      } else {\n        var newNode = {\n          name: part,\n          children: [],\n          parents: [].concat(_toConsumableArray(currentNode.parents), [currentNode.name]),\n          node: null\n        };\n        currentNode.children.push(newNode);\n        currentNode = newNode;\n      }\n    };\n    for (var i = 0; i < parts.length; i++) {\n      if (_loop()) continue;\n    }\n    currentNode.node = file;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    assertDeprecatedFormat(tree);\n  }\n  return tree;\n}\nfunction assertDeprecatedFormat(tree) {\n  for (var _iterator2 = _createForOfIteratorHelperLoose(tree.children), _step2; !(_step2 = _iterator2()).done;) {\n    var child = _step2.value;\n    if (child.node && child.children.length && !child.node.normalizedName.endsWith('_layout')) {\n      var ext = child.node.contextKey.split('.').pop();\n      throw new Error(\"Using deprecated Layout Route format: Move `./app/\" + child.node.normalizedName + \".\" + ext + \"` to `./app/\" + child.node.normalizedName + \"/_layout.\" + ext + \"`\");\n    }\n    assertDeprecatedFormat(child);\n  }\n}\nfunction getTreeNodesAsRouteNodes(nodes) {\n  return nodes.map(function (node) {\n    return treeNodeToRouteNode(node);\n  }).flat().filter(Boolean);\n}\nexport function generateDynamicFromSegment(name) {\n  var deepDynamicName = matchDeepDynamicRouteName(name);\n  var dynamicName = deepDynamicName != null ? deepDynamicName : matchDynamicName(name);\n  return dynamicName ? {\n    name: dynamicName,\n    deep: !!deepDynamicName\n  } : null;\n}\nexport function generateDynamic(name) {\n  var description = name.split('/').map(function (segment) {\n    return generateDynamicFromSegment(segment);\n  }).filter(Boolean);\n  return description.length === 0 ? null : description;\n}\nfunction collapseRouteSegments(route) {\n  return stripGroupSegmentsFromPath(route.replace(/\\/index$/, ''));\n}\nfunction getDefaultInitialRoute(node, name) {\n  return node.children.find(function (node) {\n    return collapseRouteSegments(node.route) === name;\n  });\n}\nfunction applyDefaultInitialRouteName(node) {\n  var _node$children, _getDefaultInitialRou;\n  var groupName = matchGroupName(node.route);\n  if (!((_node$children = node.children) != null && _node$children.length)) {\n    return node;\n  }\n  var initialRouteName = groupName ? (_getDefaultInitialRou = getDefaultInitialRoute(node, groupName)) == null ? void 0 : _getDefaultInitialRou.route : undefined;\n  var loaded = node.loadRoute();\n  if (loaded != null && loaded.unstable_settings) {\n    var _loaded$unstable_sett;\n    initialRouteName = (_loaded$unstable_sett = loaded.unstable_settings.initialRouteName) != null ? _loaded$unstable_sett : initialRouteName;\n    if (groupName) {\n      var _loaded$unstable_sett2, _loaded$unstable_sett3;\n      var groupSpecificInitialRouteName = (_loaded$unstable_sett2 = loaded.unstable_settings) == null ? void 0 : (_loaded$unstable_sett3 = _loaded$unstable_sett2[groupName]) == null ? void 0 : _loaded$unstable_sett3.initialRouteName;\n      initialRouteName = groupSpecificInitialRouteName != null ? groupSpecificInitialRouteName : initialRouteName;\n    }\n  }\n  return _objectSpread(_objectSpread({}, node), {}, {\n    initialRouteName: initialRouteName\n  });\n}\nfunction cloneGroupRoute(node, _ref) {\n  var nextName = _ref.name;\n  var groupName = \"(\" + nextName + \")\";\n  var parts = node.contextKey.split('/');\n  parts[parts.length - 2] = groupName;\n  return _objectSpread(_objectSpread({}, node), {}, {\n    route: groupName,\n    contextKey: parts.join('/')\n  });\n}\nfunction folderNodeToRouteNode(_ref2) {\n  var name = _ref2.name,\n    children = _ref2.children;\n  if (!children.length) {\n    return null;\n  }\n  return getTreeNodesAsRouteNodes(children.map(function (child) {\n    return _objectSpread(_objectSpread({}, child), {}, {\n      name: [name, child.name].filter(Boolean).join('/')\n    });\n  }));\n}\nfunction fileNodeToRouteNode(tree) {\n  var name = tree.name,\n    node = tree.node,\n    children = tree.children;\n  if (!node) throw new Error('node must be defined');\n  var dynamic = generateDynamic(name);\n  var groupName = matchGroupName(name);\n  var multiGroup = groupName == null ? void 0 : groupName.includes(',');\n  var clones = multiGroup ? groupName.split(',').map(function (v) {\n    return {\n      name: v.trim()\n    };\n  }) : null;\n  if (clones) {\n    var names = new Set();\n    for (var _iterator3 = _createForOfIteratorHelperLoose(clones), _step3; !(_step3 = _iterator3()).done;) {\n      var clone = _step3.value;\n      if (names.has(clone.name)) {\n        throw new Error(\"Array syntax cannot contain duplicate group name \\\"\" + clone.name + \"\\\" in \\\"\" + node.contextKey + \"\\\".\");\n      }\n      names.add(clone.name);\n    }\n  }\n  var output = {\n    loadRoute: node.loadRoute,\n    route: name,\n    contextKey: node.contextKey,\n    children: getTreeNodesAsRouteNodes(children),\n    dynamic: dynamic\n  };\n  if (Array.isArray(clones)) {\n    return clones.map(function (clone) {\n      return applyDefaultInitialRouteName(cloneGroupRoute(_objectSpread({}, output), clone));\n    });\n  }\n  return [applyDefaultInitialRouteName({\n    loadRoute: node.loadRoute,\n    route: name,\n    contextKey: node.contextKey,\n    children: getTreeNodesAsRouteNodes(children),\n    dynamic: dynamic\n  })];\n}\nfunction treeNodeToRouteNode(tree) {\n  if (tree.node) {\n    return fileNodeToRouteNode(tree);\n  }\n  return folderNodeToRouteNode(tree);\n}\nfunction contextModuleToFileNodes(contextModule) {\n  var files = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : contextModule.keys();\n  var nodes = files.map(function (key) {\n    try {\n      if (process.env.NODE_ENV === 'development') {\n        if (EXPO_ROUTER_IMPORT_MODE === 'sync') {\n          var _contextModule;\n          if (!((_contextModule = contextModule(key)) != null && _contextModule.default)) {\n            return null;\n          }\n        }\n      }\n      var node = {\n        loadRoute: function loadRoute() {\n          return contextModule(key);\n        },\n        normalizedName: getNameFromFilePath(key),\n        contextKey: key\n      };\n      return node;\n    } catch (error) {\n      console.warn('Error loading route \"' + key + '\"', error);\n    }\n    return null;\n  });\n  return nodes.filter(Boolean);\n}\nfunction hasCustomRootLayoutNode(routes) {\n  if (routes.length !== 1) {\n    return false;\n  }\n  var route = routes[0];\n  if (route.route === '' && route.contextKey.match(/^\\.\\/_layout\\.([jt]sx?)$/)) {\n    return true;\n  }\n  return false;\n}\nfunction treeNodesToRootRoute(treeNode) {\n  var routes = treeNodeToRouteNode(treeNode);\n  return withOptionalRootLayout(routes);\n}\nfunction processKeys(files, options) {\n  var ignore = options.ignore;\n  return files.filter(function (file) {\n    return !(ignore != null && ignore.some(function (pattern) {\n      return pattern.test(file);\n    }));\n  });\n}\nexport function assertDuplicateRoutes(filenames) {\n  if (process.env.NODE_ENV === 'production') {\n    return;\n  }\n  var duplicates = filenames.map(function (filename) {\n    return removeSupportedExtensions(filename);\n  }).reduce(function (acc, filename) {\n    acc[filename] = acc[filename] ? acc[filename] + 1 : 1;\n    return acc;\n  }, {});\n  Object.entries(duplicates).forEach(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n      filename = _ref4[0],\n      count = _ref4[1];\n    if (count > 1) {\n      throw new Error(\"Multiple files match the route name \\\"\" + filename + \"\\\".\");\n    }\n  });\n}\nexport function getRoutes(contextModule, options) {\n  var route = getExactRoutes(contextModule, options);\n  if (!route) {\n    return null;\n  }\n  appendSitemapRoute(route);\n  appendUnmatchedRoute(route);\n  return route;\n}\nexport function getRoutesAsync(contextModule, options) {\n  var route;\n  return _regeneratorRuntime.async(function getRoutesAsync$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        _context.next = 2;\n        return _regeneratorRuntime.awrap(getExactRoutesAsync(contextModule, options));\n      case 2:\n        route = _context.sent;\n        if (route) {\n          _context.next = 5;\n          break;\n        }\n        return _context.abrupt(\"return\", null);\n      case 5:\n        appendSitemapRoute(route);\n        appendUnmatchedRoute(route);\n        return _context.abrupt(\"return\", route);\n      case 8:\n      case \"end\":\n        return _context.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction getIgnoreList(options) {\n  var _options$ignore;\n  var ignore = [/^\\.\\/\\+html\\.[tj]sx?$/].concat(_toConsumableArray((_options$ignore = options == null ? void 0 : options.ignore) != null ? _options$ignore : []));\n  return ignore;\n}\nexport function getExactRoutes(contextModule, options) {\n  var treeNodes = contextModuleToTree(contextModule, options);\n  var route = treeNodesToRootRoute(treeNodes);\n  return route || null;\n}\nfunction contextModuleToTree(contextModule, options) {\n  var allowed = processKeys(contextModule.keys(), _objectSpread(_objectSpread({}, options), {}, {\n    ignore: getIgnoreList(options)\n  }));\n  assertDuplicateRoutes(allowed);\n  var files = contextModuleToFileNodes(contextModule, allowed);\n  return getRecursiveTree(files);\n}\nexport function getExactRoutesAsync(contextModule, options) {\n  var treeNodes, route;\n  return _regeneratorRuntime.async(function getExactRoutesAsync$(_context2) {\n    while (1) switch (_context2.prev = _context2.next) {\n      case 0:\n        treeNodes = contextModuleToTree(contextModule, options);\n        route = treeNodesToRootRoute(treeNodes);\n        return _context2.abrupt(\"return\", route || null);\n      case 3:\n      case \"end\":\n        return _context2.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction appendSitemapRoute(routes) {\n  if (!routes.children.length || routes.children.some(function (route) {\n    return route.route === '_sitemap';\n  })) {\n    return routes;\n  }\n  var _require = require(\"./views/Sitemap\"),\n    Sitemap = _require.Sitemap,\n    getNavOptions = _require.getNavOptions;\n  routes.children.push({\n    loadRoute: function loadRoute() {\n      return {\n        default: Sitemap,\n        getNavOptions: getNavOptions\n      };\n    },\n    route: '_sitemap',\n    contextKey: './_sitemap.tsx',\n    generated: true,\n    internal: true,\n    dynamic: null,\n    children: []\n  });\n  return routes;\n}\nfunction appendUnmatchedRoute(routes) {\n  var userDefinedDynamicRoute = getUserDefinedDeepDynamicRoute(routes);\n  if (!userDefinedDynamicRoute) {\n    routes.children.push({\n      loadRoute: function loadRoute() {\n        return {\n          default: require(\"./views/Unmatched\").Unmatched\n        };\n      },\n      route: '[...404]',\n      contextKey: './[...404].tsx',\n      dynamic: [{\n        name: '404',\n        deep: true\n      }],\n      children: [],\n      generated: true,\n      internal: true\n    });\n  }\n  return routes;\n}\nexport function getUserDefinedDeepDynamicRoute(routes) {\n  for (var _iterator4 = _createForOfIteratorHelperLoose((_routes$children = routes.children) != null ? _routes$children : []), _step4; !(_step4 = _iterator4()).done;) {\n    var _routes$children;\n    var route = _step4.value;\n    if (route.generated) continue;\n    var opaqueRoute = stripInvisibleSegmentsFromPath(route.route);\n    var isDeepDynamic = matchDeepDynamicRouteName(opaqueRoute);\n    if (isDeepDynamic) {\n      return route;\n    }\n    if (matchGroupName(route.route)) {\n      var child = getUserDefinedDeepDynamicRoute(route);\n      if (child) {\n        return child;\n      }\n    }\n  }\n  return null;\n}\nfunction withOptionalRootLayout(routes) {\n  if (!(routes != null && routes.length)) {\n    return null;\n  }\n  if (hasCustomRootLayoutNode(routes)) {\n    return routes[0];\n  }\n  return {\n    loadRoute: function loadRoute() {\n      return {\n        default: require(\"./views/Navigator\").DefaultNavigator\n      };\n    },\n    contextKey: './_layout.tsx',\n    route: '',\n    generated: true,\n    dynamic: null,\n    children: routes\n  };\n}","map":{"version":3,"names":["EXPO_ROUTER_IMPORT_MODE","getNameFromFilePath","matchDeepDynamicRouteName","matchDynamicName","matchGroupName","removeSupportedExtensions","stripGroupSegmentsFromPath","stripInvisibleSegmentsFromPath","getRecursiveTree","files","tree","name","children","parents","node","_iterator","_createForOfIteratorHelperLoose","_step","done","file","value","parts","normalizedName","split","currentNode","_loop","part","i","length","overwritten","contextKey","Error","existing","find","item","newNode","concat","_toConsumableArray","push","process","env","NODE_ENV","assertDeprecatedFormat","_iterator2","_step2","child","endsWith","ext","pop","getTreeNodesAsRouteNodes","nodes","map","treeNodeToRouteNode","flat","filter","Boolean","generateDynamicFromSegment","deepDynamicName","dynamicName","deep","generateDynamic","description","segment","collapseRouteSegments","route","replace","getDefaultInitialRoute","applyDefaultInitialRouteName","_node$children","_getDefaultInitialRou","groupName","initialRouteName","undefined","loaded","loadRoute","unstable_settings","_loaded$unstable_sett","_loaded$unstable_sett2","_loaded$unstable_sett3","groupSpecificInitialRouteName","_objectSpread","cloneGroupRoute","_ref","nextName","join","folderNodeToRouteNode","_ref2","fileNodeToRouteNode","dynamic","multiGroup","includes","clones","v","trim","names","Set","_iterator3","_step3","clone","has","add","output","Array","isArray","contextModuleToFileNodes","contextModule","arguments","keys","key","_contextModule","default","error","console","warn","hasCustomRootLayoutNode","routes","match","treeNodesToRootRoute","treeNode","withOptionalRootLayout","processKeys","options","ignore","some","pattern","test","assertDuplicateRoutes","filenames","duplicates","filename","reduce","acc","Object","entries","forEach","_ref3","_ref4","_slicedToArray","count","getRoutes","getExactRoutes","appendSitemapRoute","appendUnmatchedRoute","getRoutesAsync","_regeneratorRuntime","async","getRoutesAsync$","_context","prev","next","awrap","getExactRoutesAsync","sent","abrupt","stop","Promise","getIgnoreList","_options$ignore","treeNodes","contextModuleToTree","allowed","getExactRoutesAsync$","_context2","_require","require","Sitemap","getNavOptions","generated","internal","userDefinedDynamicRoute","getUserDefinedDeepDynamicRoute","Unmatched","_iterator4","_routes$children","_step4","opaqueRoute","isDeepDynamic","DefaultNavigator"],"sources":["/Users/diegollull/Desktop/Uandes/8vo_semestre/APPS/ proyecto-del-curso-llull-zarate /hybrid-frontend/node_modules/expo-router/src/getRoutes.ts"],"sourcesContent":["import type { DynamicConvention, RouteNode } from './Route';\nimport EXPO_ROUTER_IMPORT_MODE from './import-mode';\nimport {\n  getNameFromFilePath,\n  matchDeepDynamicRouteName,\n  matchDynamicName,\n  matchGroupName,\n  removeSupportedExtensions,\n  stripGroupSegmentsFromPath,\n  stripInvisibleSegmentsFromPath,\n} from './matchers';\nimport type { RequireContext } from './types';\n\nexport type FileNode = Pick<RouteNode, 'contextKey' | 'loadRoute'> & {\n  /** Like `(tab)/index` */\n  normalizedName: string;\n};\n\ntype TreeNode = {\n  name: string;\n  children: TreeNode[];\n  parents: string[];\n  /** null when there is no file in a folder. */\n  node: FileNode | null;\n};\n\ntype Options = {\n  ignore?: RegExp[];\n};\n\n/** Convert a flat map of file nodes into a nested tree of files. */\nexport function getRecursiveTree(files: FileNode[]): TreeNode {\n  const tree = {\n    name: '',\n    children: [],\n    parents: [],\n    node: null,\n  };\n\n  for (const file of files) {\n    // ['(tab)', 'settings', '[...another]']\n    const parts = file.normalizedName.split('/');\n    let currentNode: TreeNode = tree;\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i];\n\n      if (i === parts.length - 1 && part === '_layout') {\n        if (currentNode.node) {\n          const overwritten = currentNode.node.contextKey;\n          throw new Error(\n            `Higher priority Layout Route \"${file.contextKey}\" overriding redundant Layout Route \"${overwritten}\". Remove the Layout Route \"${overwritten}\" to fix this.`\n          );\n        }\n        continue;\n      }\n\n      const existing = currentNode.children.find((item) => item.name === part);\n      if (existing) {\n        currentNode = existing;\n      } else {\n        const newNode: TreeNode = {\n          name: part,\n          children: [],\n          parents: [...currentNode.parents, currentNode.name],\n          node: null,\n        };\n        currentNode.children.push(newNode);\n        currentNode = newNode;\n      }\n    }\n    currentNode.node = file;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertDeprecatedFormat(tree);\n  }\n\n  return tree;\n}\n\nfunction assertDeprecatedFormat(tree: TreeNode) {\n  for (const child of tree.children) {\n    if (child.node && child.children.length && !child.node.normalizedName.endsWith('_layout')) {\n      const ext = child.node.contextKey.split('.').pop();\n      throw new Error(\n        `Using deprecated Layout Route format: Move \\`./app/${child.node.normalizedName}.${ext}\\` to \\`./app/${child.node.normalizedName}/_layout.${ext}\\``\n      );\n    }\n    assertDeprecatedFormat(child);\n  }\n}\n\nfunction getTreeNodesAsRouteNodes(nodes: TreeNode[]): RouteNode[] {\n  return nodes\n    .map((node) => treeNodeToRouteNode(node))\n    .flat()\n    .filter(Boolean) as RouteNode[];\n}\n\nexport function generateDynamicFromSegment(name: string): DynamicConvention | null {\n  const deepDynamicName = matchDeepDynamicRouteName(name);\n  const dynamicName = deepDynamicName ?? matchDynamicName(name);\n\n  return dynamicName ? { name: dynamicName, deep: !!deepDynamicName } : null;\n}\n\nexport function generateDynamic(name: string): RouteNode['dynamic'] {\n  const description = name\n    .split('/')\n    .map((segment) => generateDynamicFromSegment(segment))\n    .filter(Boolean) as DynamicConvention[];\n  return description.length === 0 ? null : description;\n}\n\nfunction collapseRouteSegments(route: string) {\n  return stripGroupSegmentsFromPath(route.replace(/\\/index$/, ''));\n}\n\n/**\n * Given a route node and a name representing the group name,\n * find the nearest child matching the name.\n *\n * Doesn't support slashes in the name.\n * Routes like `explore/(something)/index` will be matched against `explore`.\n *\n */\nfunction getDefaultInitialRoute(node: RouteNode, name: string) {\n  return node.children.find((node) => collapseRouteSegments(node.route) === name);\n}\n\nfunction applyDefaultInitialRouteName(node: RouteNode): RouteNode {\n  const groupName = matchGroupName(node.route);\n  if (!node.children?.length) {\n    return node;\n  }\n\n  // Guess at the initial route based on the group name.\n  // TODO(EvanBacon): Perhaps we should attempt to warn when the group doesn't match any child routes.\n  let initialRouteName = groupName ? getDefaultInitialRoute(node, groupName)?.route : undefined;\n  const loaded = node.loadRoute();\n\n  if (loaded?.unstable_settings) {\n    // Allow unstable_settings={ initialRouteName: '...' } to override the default initial route name.\n    initialRouteName = loaded.unstable_settings.initialRouteName ?? initialRouteName;\n\n    if (groupName) {\n      // Allow unstable_settings={ 'custom': { initialRouteName: '...' } } to override the less specific initial route name.\n      const groupSpecificInitialRouteName = loaded.unstable_settings?.[groupName]?.initialRouteName;\n\n      initialRouteName = groupSpecificInitialRouteName ?? initialRouteName;\n    }\n  }\n\n  return {\n    ...node,\n    initialRouteName,\n  };\n}\n\nfunction cloneGroupRoute(node: RouteNode, { name: nextName }: { name: string }): RouteNode {\n  const groupName = `(${nextName})`;\n  const parts = node.contextKey.split('/');\n  parts[parts.length - 2] = groupName;\n\n  return {\n    ...node,\n    route: groupName,\n    contextKey: parts.join('/'),\n  };\n}\n\nfunction folderNodeToRouteNode({ name, children }: TreeNode): RouteNode[] | null {\n  // Empty folder, skip it.\n  if (!children.length) {\n    return null;\n  }\n\n  // When there's a directory, but no layout route file (with valid export), the child routes won't be grouped.\n  // This pushes all children into the nearest layout route.\n  return getTreeNodesAsRouteNodes(\n    children.map((child) => {\n      return {\n        ...child,\n        name: [name, child.name].filter(Boolean).join('/'),\n      };\n    })\n  );\n}\n\nfunction fileNodeToRouteNode(tree: TreeNode): RouteNode[] | null {\n  const { name, node, children } = tree;\n\n  if (!node) throw new Error('node must be defined');\n\n  const dynamic = generateDynamic(name);\n\n  const groupName = matchGroupName(name);\n  const multiGroup = groupName?.includes(',');\n\n  const clones = multiGroup ? groupName!.split(',').map((v) => ({ name: v.trim() })) : null;\n\n  // Assert duplicates:\n  if (clones) {\n    const names = new Set<string>();\n    for (const clone of clones) {\n      if (names.has(clone.name)) {\n        throw new Error(\n          `Array syntax cannot contain duplicate group name \"${clone.name}\" in \"${node.contextKey}\".`\n        );\n      }\n      names.add(clone.name);\n    }\n  }\n\n  const output = {\n    loadRoute: node.loadRoute,\n    route: name,\n    contextKey: node.contextKey,\n    children: getTreeNodesAsRouteNodes(children),\n    dynamic,\n  };\n\n  if (Array.isArray(clones)) {\n    return clones.map((clone) =>\n      applyDefaultInitialRouteName(cloneGroupRoute({ ...output }, clone))\n    );\n  }\n\n  return [\n    applyDefaultInitialRouteName({\n      loadRoute: node.loadRoute,\n      route: name,\n      contextKey: node.contextKey,\n      children: getTreeNodesAsRouteNodes(children),\n      dynamic,\n    }),\n  ];\n}\n\nfunction treeNodeToRouteNode(tree: TreeNode): RouteNode[] | null {\n  if (tree.node) {\n    return fileNodeToRouteNode(tree);\n  }\n\n  return folderNodeToRouteNode(tree);\n}\n\nfunction contextModuleToFileNodes(\n  contextModule: RequireContext,\n  files: string[] = contextModule.keys()\n): FileNode[] {\n  const nodes = files.map((key) => {\n    // In development, check if the file exports a default component\n    // this helps keep things snappy when creating files. In production we load all screens lazily.\n    try {\n      if (process.env.NODE_ENV === 'development') {\n        // If the user has set the `EXPO_ROUTER_IMPORT_MODE` to `sync` then we should\n        // filter the missing routes.\n        if (EXPO_ROUTER_IMPORT_MODE === 'sync') {\n          if (!contextModule(key)?.default) {\n            return null;\n          }\n        }\n      }\n      const node: FileNode = {\n        loadRoute() {\n          return contextModule(key);\n        },\n        normalizedName: getNameFromFilePath(key),\n        contextKey: key,\n      };\n\n      return node;\n    } catch (error) {\n      // Probably this won't stop metro from freaking out but it's worth a try.\n      console.warn('Error loading route \"' + key + '\"', error);\n    }\n    return null;\n  });\n\n  return nodes.filter(Boolean) as FileNode[];\n}\n\nfunction hasCustomRootLayoutNode(routes: RouteNode[]) {\n  if (routes.length !== 1) {\n    return false;\n  }\n  // This could either be the root _layout or an app with a single file.\n  const route = routes[0];\n\n  if (route.route === '' && route.contextKey.match(/^\\.\\/_layout\\.([jt]sx?)$/)) {\n    return true;\n  }\n  return false;\n}\n\nfunction treeNodesToRootRoute(treeNode: TreeNode): RouteNode | null {\n  const routes = treeNodeToRouteNode(treeNode);\n  return withOptionalRootLayout(routes);\n}\n\nfunction processKeys(files: string[], options: Options): string[] {\n  const { ignore } = options;\n\n  return files.filter((file) => {\n    return !ignore?.some((pattern) => pattern.test(file));\n  });\n}\n\n/**\n * Asserts if the require.context has files that share the same name but have different extensions. Exposed for testing.\n * @private\n */\nexport function assertDuplicateRoutes(filenames: string[]) {\n  if (process.env.NODE_ENV === 'production') {\n    return;\n  }\n\n  const duplicates = filenames\n    .map((filename) => removeSupportedExtensions(filename))\n    .reduce(\n      (acc, filename) => {\n        acc[filename] = acc[filename] ? acc[filename] + 1 : 1;\n        return acc;\n      },\n      {} as Record<string, number>\n    );\n\n  Object.entries(duplicates).forEach(([filename, count]) => {\n    if (count > 1) {\n      throw new Error(`Multiple files match the route name \"${filename}\".`);\n    }\n  });\n}\n\n/** Given a Metro context module, return an array of nested routes. */\nexport function getRoutes(contextModule: RequireContext, options?: Options): RouteNode | null {\n  const route = getExactRoutes(contextModule, options);\n\n  // If there is no route, return an empty route.\n  if (!route) {\n    return null;\n  }\n\n  appendSitemapRoute(route);\n\n  // Auto add not found route if it doesn't exist\n  appendUnmatchedRoute(route);\n\n  return route;\n}\n\nexport async function getRoutesAsync(\n  contextModule: RequireContext,\n  options?: Options\n): Promise<RouteNode | null> {\n  const route = await getExactRoutesAsync(contextModule, options);\n  if (!route) {\n    return null;\n  }\n\n  appendSitemapRoute(route);\n\n  // Auto add not found route if it doesn't exist\n  appendUnmatchedRoute(route);\n\n  return route;\n}\n\nfunction getIgnoreList(options?: Options) {\n  const ignore: RegExp[] = [/^\\.\\/\\+html\\.[tj]sx?$/, ...(options?.ignore ?? [])];\n  return ignore;\n}\n\n/** Get routes without unmatched or sitemap. */\nexport function getExactRoutes(contextModule: RequireContext, options?: Options): RouteNode | null {\n  const treeNodes = contextModuleToTree(contextModule, options);\n  const route = treeNodesToRootRoute(treeNodes);\n  return route || null;\n}\n\nfunction contextModuleToTree(contextModule: RequireContext, options?: Options) {\n  const allowed = processKeys(contextModule.keys(), {\n    ...options,\n    ignore: getIgnoreList(options),\n  });\n  assertDuplicateRoutes(allowed);\n  const files = contextModuleToFileNodes(contextModule, allowed);\n  return getRecursiveTree(files);\n}\n\nexport async function getExactRoutesAsync(\n  contextModule: RequireContext,\n  options?: Options\n): Promise<RouteNode | null> {\n  const treeNodes = contextModuleToTree(contextModule, options);\n  const route = treeNodesToRootRoute(treeNodes);\n  return route || null;\n}\n\nfunction appendSitemapRoute(routes: RouteNode) {\n  if (\n    !routes.children.length ||\n    // Allow overriding the sitemap route\n    routes.children.some((route) => route.route === '_sitemap')\n  ) {\n    return routes;\n  }\n  const { Sitemap, getNavOptions } = require('./views/Sitemap');\n  routes.children.push({\n    loadRoute() {\n      return { default: Sitemap, getNavOptions };\n    },\n    route: '_sitemap',\n    contextKey: './_sitemap.tsx',\n    generated: true,\n    internal: true,\n    dynamic: null,\n    children: [],\n  });\n  return routes;\n}\n\nfunction appendUnmatchedRoute(routes: RouteNode) {\n  // Auto add not found route if it doesn't exist\n  const userDefinedDynamicRoute = getUserDefinedDeepDynamicRoute(routes);\n  if (!userDefinedDynamicRoute) {\n    routes.children.push({\n      loadRoute() {\n        return { default: require('./views/Unmatched').Unmatched };\n      },\n      route: '[...404]',\n      contextKey: './[...404].tsx',\n      dynamic: [{ name: '404', deep: true }],\n      children: [],\n      generated: true,\n      internal: true,\n    });\n  }\n  return routes;\n}\n\n/**\n * Exposed for testing.\n * @returns a top-level deep dynamic route if it exists, otherwise null.\n */\nexport function getUserDefinedDeepDynamicRoute(routes: RouteNode): RouteNode | null {\n  // Auto add not found route if it doesn't exist\n  for (const route of routes.children ?? []) {\n    if (route.generated) continue;\n    const opaqueRoute = stripInvisibleSegmentsFromPath(route.route);\n    const isDeepDynamic = matchDeepDynamicRouteName(opaqueRoute);\n    if (isDeepDynamic) {\n      return route;\n    }\n    // Recurse through group routes\n    if (matchGroupName(route.route)) {\n      const child = getUserDefinedDeepDynamicRoute(route);\n      if (child) {\n        return child;\n      }\n    }\n  }\n  return null;\n}\n\nfunction withOptionalRootLayout(routes: RouteNode[] | null): RouteNode | null {\n  if (!routes?.length) {\n    return null;\n  }\n\n  if (hasCustomRootLayoutNode(routes)) {\n    return routes[0];\n  }\n\n  return {\n    loadRoute: () => ({\n      default: (require('./views/Navigator') as typeof import('./views/Navigator'))\n        .DefaultNavigator,\n    }),\n    // Generate a fake file name for the directory\n    contextKey: './_layout.tsx',\n    route: '',\n    generated: true,\n    dynamic: null,\n    children: routes,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}