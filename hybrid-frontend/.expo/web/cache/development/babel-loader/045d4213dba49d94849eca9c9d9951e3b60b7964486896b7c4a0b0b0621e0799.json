{"ast":null,"code":"import { CommonActions, getActionFromState, StackActions } from '@react-navigation/core';\nimport { TabActions } from '@react-navigation/native';\nimport * as Linking from 'expo-linking';\nimport { resolveHref } from \"../link/href\";\nimport { resolve } from \"../link/path\";\nimport { findTopRouteForTarget, getEarliestMismatchedRoute, getQualifiedStateForTopOfTargetState, isMovingToSiblingRoute } from \"../link/stateOperations\";\nimport { hasUrlProtocolPrefix } from \"../utils/url\";\nfunction assertIsReady(store) {\n  if (!store.navigationRef.isReady()) {\n    throw new Error('Attempted to navigate before mounting the Root Layout component. Ensure the Root Layout component is rendering a Slot, or other navigator on the first render.');\n  }\n}\nexport function push(url) {\n  return this.linkTo(resolveHref(url));\n}\nexport function replace(url) {\n  return this.linkTo(resolveHref(url), 'REPLACE');\n}\nexport function goBack() {\n  var _this$navigationRef, _this$navigationRef$c;\n  assertIsReady(this);\n  (_this$navigationRef = this.navigationRef) == null ? void 0 : (_this$navigationRef$c = _this$navigationRef.current) == null ? void 0 : _this$navigationRef$c.goBack();\n}\nexport function canGoBack() {\n  var _this$navigationRef$c2, _this$navigationRef2, _this$navigationRef2$;\n  if (!this.navigationRef.isReady()) {\n    return false;\n  }\n  return (_this$navigationRef$c2 = (_this$navigationRef2 = this.navigationRef) == null ? void 0 : (_this$navigationRef2$ = _this$navigationRef2.current) == null ? void 0 : _this$navigationRef2$.canGoBack()) != null ? _this$navigationRef$c2 : false;\n}\nexport function setParams() {\n  var _this$navigationRef3, _this$navigationRef3$;\n  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  assertIsReady(this);\n  return ((_this$navigationRef3 = this.navigationRef) == null ? void 0 : (_this$navigationRef3$ = _this$navigationRef3.current) == null ? void 0 : _this$navigationRef3$.setParams.bind(_this$navigationRef3$))(params);\n}\nexport function linkTo(href, event) {\n  if (hasUrlProtocolPrefix(href)) {\n    Linking.openURL(href);\n    return;\n  }\n  assertIsReady(this);\n  var navigationRef = this.navigationRef.current;\n  if (navigationRef == null) {\n    throw new Error(\"Couldn't find a navigation object. Is your component inside NavigationContainer?\");\n  }\n  if (!this.linking) {\n    throw new Error('Attempted to link to route when no routes are present');\n  }\n  if (href === '..' || href === '../') {\n    navigationRef.goBack();\n    return;\n  }\n  if (href.startsWith('.')) {\n    var _this$linking$getPath, _this$linking$getPath2, _this$linking;\n    var base = (_this$linking$getPath = (_this$linking$getPath2 = (_this$linking = this.linking).getPathFromState) == null ? void 0 : _this$linking$getPath2.call(_this$linking, navigationRef.getRootState(), {\n      screens: [],\n      preserveGroups: true\n    })) != null ? _this$linking$getPath : '';\n    if (base && !base.endsWith('/')) {\n      base += '/..';\n    }\n    href = resolve(base, href);\n  }\n  var state = this.linking.getStateFromPath(href, this.linking.config);\n  if (!state) {\n    console.error('Could not generate a valid navigation state for the given path: ' + href);\n    return;\n  }\n  var rootState = navigationRef.getRootState();\n  if (isMovingToSiblingRoute(rootState, state)) {\n    var _findTopRouteForTarge;\n    var knownOwnerState = getQualifiedStateForTopOfTargetState(rootState, state);\n    var nextRoute = findTopRouteForTarget(state);\n    if (((_findTopRouteForTarge = findTopRouteForTarget(rootState)) == null ? void 0 : _findTopRouteForTarge.name) !== nextRoute.name) {\n      if (event === 'REPLACE') {\n        if (knownOwnerState.type === 'tab') {\n          navigationRef.dispatch(TabActions.jumpTo(nextRoute.name, nextRoute.params));\n        } else {\n          navigationRef.dispatch(StackActions.replace(nextRoute.name, nextRoute.params));\n        }\n      } else {\n        navigationRef.dispatch(CommonActions.navigate(nextRoute.name, nextRoute.params));\n      }\n      return;\n    }\n  }\n  var action = getActionFromState(state, this.linking.config);\n  if (action) {\n    if (event === 'REPLACE' && isAbsoluteInitialRoute(action)) {\n      var earliest = getEarliestMismatchedRoute(rootState, action.payload);\n      if (earliest) {\n        if (earliest.type === 'stack') {\n          navigationRef.dispatch(StackActions.replace(earliest.name, earliest.params));\n        } else {\n          navigationRef.dispatch(TabActions.jumpTo(earliest.name, earliest.params));\n        }\n        return;\n      } else {}\n    }\n    navigationRef.dispatch(action);\n  } else {\n    navigationRef.reset(state);\n  }\n}\nexport function isAbsoluteInitialRoute(action) {\n  if ((action == null ? void 0 : action.type) !== 'NAVIGATE') {\n    return false;\n  }\n  var next = action.payload.params;\n  while (next) {\n    if (!isNavigationState(next)) {\n      return false;\n    }\n    if (next.initial === true) {\n      next = next.params;\n    } else if (next.initial === false) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isNavigationState(obj) {\n  return 'initial' in obj;\n}","map":{"version":3,"names":["CommonActions","getActionFromState","StackActions","TabActions","Linking","resolveHref","resolve","findTopRouteForTarget","getEarliestMismatchedRoute","getQualifiedStateForTopOfTargetState","isMovingToSiblingRoute","hasUrlProtocolPrefix","assertIsReady","store","navigationRef","isReady","Error","push","url","linkTo","replace","goBack","_this$navigationRef","_this$navigationRef$c","current","canGoBack","_this$navigationRef$c2","_this$navigationRef2","_this$navigationRef2$","setParams","_this$navigationRef3","_this$navigationRef3$","params","arguments","length","undefined","bind","href","event","openURL","linking","startsWith","_this$linking$getPath","_this$linking$getPath2","_this$linking","base","getPathFromState","call","getRootState","screens","preserveGroups","endsWith","state","getStateFromPath","config","console","error","rootState","_findTopRouteForTarge","knownOwnerState","nextRoute","name","type","dispatch","jumpTo","navigate","action","isAbsoluteInitialRoute","earliest","payload","reset","next","isNavigationState","initial","obj"],"sources":["/Users/diegollull/Desktop/Uandes/8vo_semestre/APPS/ proyecto-del-curso-llull-zarate /hybrid-frontend/node_modules/expo-router/src/global-state/routing.ts"],"sourcesContent":["import { CommonActions, getActionFromState, StackActions } from '@react-navigation/core';\nimport { TabActions } from '@react-navigation/native';\nimport * as Linking from 'expo-linking';\n\nimport type { RouterStore } from './router-store';\nimport { Href, resolveHref } from '../link/href';\nimport { resolve } from '../link/path';\nimport {\n  NavigateAction,\n  findTopRouteForTarget,\n  getEarliestMismatchedRoute,\n  getQualifiedStateForTopOfTargetState,\n  isMovingToSiblingRoute,\n} from '../link/stateOperations';\nimport { hasUrlProtocolPrefix } from '../utils/url';\n\nfunction assertIsReady(store: RouterStore) {\n  if (!store.navigationRef.isReady()) {\n    throw new Error(\n      'Attempted to navigate before mounting the Root Layout component. Ensure the Root Layout component is rendering a Slot, or other navigator on the first render.'\n    );\n  }\n}\n\nexport function push(this: RouterStore, url: Href) {\n  return this.linkTo(resolveHref(url));\n}\n\nexport function replace(this: RouterStore, url: Href) {\n  return this.linkTo(resolveHref(url), 'REPLACE');\n}\n\nexport function goBack(this: RouterStore) {\n  assertIsReady(this);\n  this.navigationRef?.current?.goBack();\n}\n\nexport function canGoBack(this: RouterStore): boolean {\n  // Return a default value here if the navigation hasn't mounted yet.\n  // This can happen if the user calls `canGoBack` from the Root Layout route\n  // before mounting a navigator. This behavior exists due to React Navigation being dynamically\n  // constructed at runtime. We can get rid of this in the future if we use\n  // the static configuration internally.\n  if (!this.navigationRef.isReady()) {\n    return false;\n  }\n  return this.navigationRef?.current?.canGoBack() ?? false;\n}\n\nexport function setParams(this: RouterStore, params: Record<string, string | number> = {}) {\n  assertIsReady(this);\n  return (this.navigationRef?.current?.setParams as any)(params);\n}\n\nexport function linkTo(this: RouterStore, href: string, event?: string) {\n  if (hasUrlProtocolPrefix(href)) {\n    Linking.openURL(href);\n    return;\n  }\n\n  assertIsReady(this);\n  const navigationRef = this.navigationRef.current;\n\n  if (navigationRef == null) {\n    throw new Error(\n      \"Couldn't find a navigation object. Is your component inside NavigationContainer?\"\n    );\n  }\n\n  if (!this.linking) {\n    throw new Error('Attempted to link to route when no routes are present');\n  }\n\n  if (href === '..' || href === '../') {\n    navigationRef.goBack();\n    return;\n  }\n\n  if (href.startsWith('.')) {\n    let base =\n      this.linking.getPathFromState?.(navigationRef.getRootState(), {\n        screens: [],\n        preserveGroups: true,\n      }) ?? '';\n\n    if (base && !base.endsWith('/')) {\n      base += '/..';\n    }\n    href = resolve(base, href);\n  }\n\n  const state = this.linking.getStateFromPath!(href, this.linking.config);\n\n  if (!state) {\n    console.error('Could not generate a valid navigation state for the given path: ' + href);\n    return;\n  }\n\n  const rootState = navigationRef.getRootState();\n\n  // Ensure simple operations are used when moving between siblings\n  // in the same navigator. This ensures that the state is not reset.\n  // TODO: We may need to apply this at a larger scale in the future.\n  if (isMovingToSiblingRoute(rootState, state)) {\n    // Can perform naive movements\n    const knownOwnerState = getQualifiedStateForTopOfTargetState(rootState, state)!;\n    const nextRoute = findTopRouteForTarget(state);\n    // NOTE(EvanBacon): There's an issue where moving from \"a -> b\" is considered siblings:\n    // a. index (initialRouteName=\"index\")\n    // b. stack/index\n    // However, the preservation approach doesn't work because it would be moving to a route with the same name.\n    // The next check will see if the current focused route has the same name as the next route, if so, then fallback on\n    // the default React Navigation logic.\n    if (\n      findTopRouteForTarget(\n        // @ts-expect-error: stale types don't matter here\n        rootState\n      )?.name !== nextRoute.name\n    ) {\n      if (event === 'REPLACE') {\n        if (knownOwnerState.type === 'tab') {\n          navigationRef.dispatch(TabActions.jumpTo(nextRoute.name, nextRoute.params));\n        } else {\n          navigationRef.dispatch(StackActions.replace(nextRoute.name, nextRoute.params));\n        }\n      } else {\n        // NOTE: Not sure if we should pop or push here...\n        navigationRef.dispatch(CommonActions.navigate(nextRoute.name, nextRoute.params));\n      }\n      return;\n    }\n  }\n\n  // TODO: Advanced movements across multiple navigators\n\n  const action = getActionFromState(state, this.linking.config);\n  if (action) {\n    // Here we have a navigation action to a nested screen, where we should ideally replace.\n    // This request can only be fulfilled if the target is an initial route.\n    // First, check if the action is fully initial routes.\n    // Then find the nearest mismatched route in the existing state.\n    // Finally, use the correct navigator-based action to replace the nested screens.\n    // NOTE(EvanBacon): A future version of this will involve splitting the navigation request so we replace as much as possible, then push the remaining screens to fulfill the request.\n    if (event === 'REPLACE' && isAbsoluteInitialRoute(action)) {\n      const earliest = getEarliestMismatchedRoute(rootState, action.payload);\n      if (earliest) {\n        if (earliest.type === 'stack') {\n          navigationRef.dispatch(StackActions.replace(earliest.name, earliest.params));\n        } else {\n          navigationRef.dispatch(TabActions.jumpTo(earliest.name, earliest.params));\n        }\n        return;\n      } else {\n        // This should never happen because moving to the same route would be handled earlier\n        // in the sibling operations.\n      }\n    }\n\n    // Ignore the replace event here since replace across\n    // navigators is not supported.\n    navigationRef.dispatch(action);\n  } else {\n    navigationRef.reset(state);\n  }\n}\n\n/** @returns `true` if the action is moving to the first screen of all the navigators in the action. */\nexport function isAbsoluteInitialRoute(\n  action: ReturnType<typeof getActionFromState>\n): action is NavigateAction {\n  if (action?.type !== 'NAVIGATE') {\n    return false;\n  }\n\n  let next = action.payload.params;\n  // iterate all child screens and bail out if any are not initial.\n  while (next) {\n    if (!isNavigationState(next)) {\n      // Not sure when this would happen\n      return false;\n    }\n    if (next.initial === true) {\n      next = next.params;\n      // return true;\n    } else if (next.initial === false) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\ntype NavStateParams = {\n  params?: NavStateParams;\n  path: string;\n  initial: boolean;\n  screen: string;\n  state: unknown;\n};\n\nfunction isNavigationState(obj: any): obj is NavStateParams {\n  return 'initial' in obj;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}